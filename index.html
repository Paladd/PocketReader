<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#0b0c10" />
  <title>Pocket Reader</title>
  <link rel="manifest" href="./manifest.webmanifest" />

  <style>
    :root{
      --bg:#0b0c10; --card:#12141b; --panel:#0f1220;
      --stroke:#22263a; --stroke2:#2b3150;
      --text:#e7e7e7; --muted:#aeb3c7; --brand:#2a5bd7; --danger:#b63b3b;
      color-scheme: dark;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    body{ margin:0; background:var(--bg); color:var(--text); }
    .app{ min-height:100vh; display:grid; grid-template-rows:auto auto 1fr; }

    .topbar{
      position:sticky; top:0; z-index:50;
      background:rgba(18,20,27,.92); backdrop-filter: blur(10px);
      border-bottom:1px solid var(--stroke);
      padding:12px 14px; display:flex; align-items:flex-start; gap:10px;
    }
    .logo{ width:34px; height:34px; border-radius:10px;
      background:linear-gradient(135deg, var(--brand), #8ab4ff);
      box-shadow: 0 10px 30px rgba(42,91,215,.25);
      flex:0 0 auto; margin-top:2px;
    }
    h1{ margin:0; font-size:16px; }
    .sub{ margin:4px 0 0 0; font-size:12px; color:var(--muted); white-space:pre-wrap; }

    .chipbar{
      padding:10px 12px; display:flex; gap:8px; flex-wrap:wrap;
      border-bottom:1px solid var(--stroke);
      background:rgba(15,18,32,.55);
    }
    .chip{
      border:1px solid var(--stroke2);
      background:rgba(18,20,27,.65);
      color:var(--text);
      padding:8px 12px;
      border-radius:999px;
      font-weight:800;
      cursor:pointer;
      user-select:none;
      font-size:13px;
    }
    .chip.active{ border-color:var(--brand); box-shadow: 0 0 0 3px rgba(42,91,215,.15); }

    .content{
      padding:12px;
      display:grid;
      grid-template-columns: 420px 1fr;
      gap:12px;
    }
    @media (max-width: 980px){ .content{ grid-template-columns: 1fr; } }

    .card{
      background:var(--card);
      border:1px solid var(--stroke);
      border-radius:16px;
      overflow:hidden;
      box-shadow: 0 10px 30px rgba(0,0,0,.25);
    }
    .hd{
      padding:12px;
      display:flex; align-items:center; justify-content:space-between;
      border-bottom:1px solid var(--stroke);
      font-weight:900;
    }
    .bd{ padding:12px; }

    input, select, button, textarea{
      width:100%;
      box-sizing:border-box;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid var(--stroke2);
      background:var(--panel);
      color:var(--text);
      outline:none;
      font-size:14px;
    }
    textarea{ min-height:90px; resize:vertical; }
    button{ cursor:pointer; font-weight:900; }
    .primary{ background:var(--brand); border-color:var(--brand); }
    .ghost{ background:transparent; }
    .row{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    .row > *{ flex:1; }

    .muted{ color:var(--muted); font-size:12px; }
    .status{ margin-top:8px; font-size:12px; color:#9fe6b8; white-space:pre-wrap; }
    .warn{ color:#ffd27d; }
    .dangerText{ color:#ff9f9f; }

    #reader{
      line-height:1.7;
      font-size:18px;
      padding:16px;
      background:var(--panel);
      border-radius:16px;
      min-height:280px;
      max-height:62vh;
      overflow:auto;
      border:1px solid var(--stroke);
      user-select: text; /* important for selection */
      -webkit-user-select: text;
    }
    .sent{
      display:inline;
      padding:.08em .05em;
      border-radius:8px;
      cursor:pointer;
    }
    .sent:hover{ background: rgba(255,255,255,.06); }
    .sent.active{ background: rgba(42,91,215,.22); outline:1px solid rgba(42,91,215,.45); }

    .playerFab{
      position: fixed; right: 14px; bottom: 14px; z-index: 60;
      display: flex; flex-direction: column; align-items: flex-end; gap: 10px;
    }
    .fabMain{
      border-radius: 999px;
      padding: 12px 14px;
      border: 1px solid var(--stroke2);
      background: rgba(18,20,27,.92);
      backdrop-filter: blur(10px);
      display: flex; align-items: center; gap: 10px;
      box-shadow: 0 14px 40px rgba(0,0,0,.35);
      width:auto;
    }
    .fabPanel{
      width: min(420px, calc(100vw - 28px));
      border-radius: 16px;
      border: 1px solid var(--stroke);
      background: rgba(18,20,27,.92);
      backdrop-filter: blur(10px);
      padding: 12px;
      box-shadow: 0 18px 60px rgba(0,0,0,.45);
      display: none;
    }
    .fabPanel.open{ display: block; }
    .tiny{ font-size:11px; color:var(--muted); }

    /* Selection helper bar */
    .selectBar{
      display:none;
      margin-top:10px;
      padding:10px;
      border-radius:12px;
      border:1px solid var(--stroke2);
      background: rgba(15,18,32,.75);
    }
    .selectBar.show{ display:block; }
  </style>

  <!-- DOCX engine -->
  <script src="https://cdn.jsdelivr.net/npm/mammoth/mammoth.browser.min.js"></script>

  <!-- PDF.js legacy build -->
  <script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@3.4.120/legacy/build/pdf.min.js"></script>
</head>

<body>
<div class="app">
  <div class="topbar">
    <div class="logo"></div>
    <div>
      <h1>Pocket Reader</h1>
      <div class="sub" id="aliveBanner">BUILD v21 • JS: starting…</div>
    </div>
  </div>

  <div class="chipbar">
    <div class="chip active" data-tab="load">Load</div>
    <div class="chip" data-tab="gutenberg">Gutenberg</div>
  </div>

  <div class="content">
    <section class="card">
      <div class="hd"><span id="leftTitle">Load</span></div>
      <div class="bd">

        <div class="tab" id="tab-load">
          <div class="muted">Tip: Use “Any File” on iPhone for the most reliable picker.</div>
          <div style="height:10px;"></div>

          <div class="muted">Any File (recommended)</div>
          <input id="anyFileInput" type="file" accept="*/*" />

          <div style="height:10px;"></div>
          <div class="muted">Filtered picker (optional)</div>
          <input id="fileInput" type="file"
                 accept=".txt,.text,.md,.html,.htm,.docx,.pdf,application/pdf,application/vnd.openxmlformats-officedocument.wordprocessingml.document" />

          <div id="fileStatus" class="status"></div>

          <div style="height:14px;"></div>
          <div class="muted">Or paste text:</div>
          <textarea id="pasteBox" placeholder="Paste text here..."></textarea>
          <div class="row" style="margin-top:8px;">
            <button id="usePaste" class="primary">Load pasted text</button>
            <button id="clearText" class="ghost">Clear</button>
          </div>

          <div style="height:14px;"></div>
          <div class="tiny">
            Start reading options:
            <br>• Tap a sentence in Reader to set the start point.
            <br>• Or highlight text in Reader, then use “Start Here (Selection)”.
          </div>
        </div>

        <div class="tab" id="tab-gutenberg" style="display:none;">
          <div class="muted">Search Project Gutenberg (via Gutendex) and load into Reader.</div>
          <div style="height:10px;"></div>
          <div class="row">
            <input id="gbQuery" type="text" placeholder="Search title or author" />
            <button id="gbSearch" class="primary" style="width:auto;">Search</button>
          </div>
          <div id="gbStatus" class="status"></div>
          <div id="gbResults" class="status" style="white-space:normal;"></div>
        </div>

      </div>
    </section>

    <section class="card">
      <div class="hd">
        <span id="docLabel">Reader</span>
        <span class="muted" id="modeLabel">mode: text</span>
      </div>
      <div class="bd">
        <div id="reader">Load something, then tap ▶ to speak.</div>

        <!-- Selection action bar -->
        <div class="selectBar" id="selectBar">
          <div class="muted" style="margin-bottom:8px;">Selection detected</div>
          <div class="row">
            <button id="startFromSelection" class="primary" style="width:auto;">Start Here (Selection)</button>
            <button id="clearSelection" class="ghost" style="width:auto;">Clear selection</button>
          </div>
          <div class="tiny" id="selectionPreview" style="margin-top:8px;"></div>
        </div>

        <div id="ttsStatus" class="status"></div>
      </div>
    </section>
  </div>

  <div class="playerFab">
    <button class="fabMain" id="fabToggle" aria-label="Toggle player">
      <span id="fabIcon">▶</span>
      <span class="muted" id="fabVoice">Voice</span>
    </button>

    <div class="fabPanel" id="fabPanel">
      <div class="muted">Voice</div>
      <select id="voiceSelect"></select>
      <div class="tiny">Note: iOS often exposes only a few usable voices to web apps. Samantha is commonly the best free option.</div>

      <div style="height:10px;"></div>
      <div class="row">
        <button id="speak" class="primary" style="width:auto;">▶ Speak</button>
        <button id="pause" class="ghost" style="width:auto;">⏸</button>
        <button id="resume" class="ghost" style="width:auto;">⏵</button>
        <button id="stop" class="ghost" style="width:auto;">■</button>
      </div>

      <div style="height:12px;"></div>
      <div class="muted">Rate</div>
      <input id="rate" type="range" min="0.75" max="1.15" value="0.98" step="0.01" />

      <div style="height:12px;"></div>
      <div class="muted">Pitch</div>
      <input id="pitch" type="range" min="0.85" max="1.15" value="1.00" step="0.01" />

      <div style="height:12px;"></div>
      <div class="muted">Pause after sentence (ms)</div>
      <input id="pauseMs" type="range" min="0" max="900" value="250" step="25" />
      <div class="tiny" id="pauseMsLabel">250 ms</div>
    </div>
  </div>
</div>

<script>
  // ===== Banner truth =====
  const aliveBanner = document.getElementById("aliveBanner");
  function setBanner(){
    const docxOk = typeof window.mammoth !== "undefined";
    const pdfOk = typeof window.pdfjsLib !== "undefined";
    aliveBanner.textContent = `BUILD v21 • JS: RUNNING ✅ • DOCX: ${docxOk ? "LOADED ✅" : "MISSING ❌"} • PDF: ${pdfOk ? "LOADED ✅" : "MISSING ❌"}`;
  }
  setBanner();

  // ===== Tabs =====
  const chips = [...document.querySelectorAll(".chip")];
  const tabs = {
    load: document.getElementById("tab-load"),
    gutenberg: document.getElementById("tab-gutenberg"),
  };
  const leftTitle = document.getElementById("leftTitle");
  function setTab(name){
    chips.forEach(c => c.classList.toggle("active", c.dataset.tab === name));
    Object.entries(tabs).forEach(([k,el]) => el.style.display = (k===name ? "block" : "none"));
    leftTitle.textContent = name.charAt(0).toUpperCase() + name.slice(1);
  }
  chips.forEach(c => c.addEventListener("click", () => setTab(c.dataset.tab)));

  // ===== DOM =====
  const fileInput = document.getElementById("fileInput");
  const anyFileInput = document.getElementById("anyFileInput");
  const fileStatus = document.getElementById("fileStatus");

  const reader = document.getElementById("reader");
  const docLabel = document.getElementById("docLabel");
  const modeLabel = document.getElementById("modeLabel");
  const ttsStatus = document.getElementById("ttsStatus");

  const selectBar = document.getElementById("selectBar");
  const selectionPreview = document.getElementById("selectionPreview");
  const startFromSelectionBtn = document.getElementById("startFromSelection");
  const clearSelectionBtn = document.getElementById("clearSelection");

  const voiceSelect = document.getElementById("voiceSelect");
  const rate = document.getElementById("rate");
  const pitch = document.getElementById("pitch");
  const pauseMs = document.getElementById("pauseMs");
  const pauseMsLabel = document.getElementById("pauseMsLabel");

  const fabToggle = document.getElementById("fabToggle");
  const fabPanel = document.getElementById("fabPanel");
  const fabVoice = document.getElementById("fabVoice");
  const fabIcon = document.getElementById("fabIcon");

  function setStatus(el, msg, kind="ok"){
    el.textContent = msg || "";
    el.className = "status " + (kind==="warn" ? "warn" : (kind==="danger" ? "dangerText" : ""));
  }

  // ===== Reader + Start control =====
  const state = { textRaw: "", voices: [] };
  let sentenceList = [];
  let startIndex = 0;

  function splitIntoSentences(text){
    const t = (text || "").replace(/\r\n/g, "\n").trim();
    if (!t) return [];
    const normalized = t.replace(/\n{3,}/g, "\n\n").replace(/[ \t]+/g, " ");
    const parts = normalized.split(/(?<=[.!?])\s+(?=[A-Z0-9“"'\(\[])/g);
    return parts.map(s => s.trim()).filter(Boolean);
  }

  function highlightSentence(i){
    startIndex = Math.max(0, Math.min(i, sentenceList.length - 1));
    [...reader.querySelectorAll(".sent")].forEach(el => el.classList.remove("active"));
    const el = reader.querySelector(`.sent[data-i="${startIndex}"]`);
    if (el) el.classList.add("active");
    setStatus(ttsStatus, `Start set at sentence ${startIndex + 1}.`, "ok");
  }

  function renderSentences(text){
    sentenceList = splitIntoSentences(text);
    startIndex = 0;

    reader.innerHTML = "";
    if (!sentenceList.length){
      reader.textContent = "No text loaded.";
      return;
    }

    sentenceList.forEach((s, i) => {
      const span = document.createElement("span");
      span.className = "sent";
      span.dataset.i = String(i);
      span.textContent = s + " ";
      span.addEventListener("click", () => highlightSentence(i));
      reader.appendChild(span);
    });

    highlightSentence(0);
  }

  function loadText(text, label){
    state.textRaw = (text || "").trim();
    docLabel.textContent = label || "Reader";
    modeLabel.textContent = "mode: text";
    renderSentences(state.textRaw);
    hideSelectionBar();
  }

  // ===== Selection-based "Start Here" =====
  function getSelectedTextInReader(){
    const sel = window.getSelection ? window.getSelection() : null;
    if (!sel || sel.rangeCount === 0) return "";

    const range = sel.getRangeAt(0);
    if (!reader.contains(range.commonAncestorContainer)) return "";
    const txt = sel.toString().trim();
    return txt;
  }

  function showSelectionBar(txt){
    if (!txt) return hideSelectionBar();
    selectBar.classList.add("show");
    const preview = txt.length > 200 ? (txt.slice(0, 200) + "…") : txt;
    selectionPreview.textContent = `“${preview}”`;
  }

  function hideSelectionBar(){
    selectBar.classList.remove("show");
    selectionPreview.textContent = "";
  }

  function clearSelection(){
    const sel = window.getSelection ? window.getSelection() : null;
    if (sel) sel.removeAllRanges();
    hideSelectionBar();
  }

  function setStartFromSelection(){
    const txt = getSelectedTextInReader();
    if (!txt){
      setStatus(ttsStatus, "No selection found. Highlight text in the Reader first.", "warn");
      return;
    }

    // Find best matching sentence by searching raw text
    // Prefer the first sentence containing the selection (or a trimmed chunk of it).
    const needle = txt.slice(0, 80).replace(/\s+/g, " ").trim();
    let idx = 0;

    for (let i = 0; i < sentenceList.length; i++){
      const s = sentenceList[i];
      if (s.includes(txt) || s.includes(needle)){
        idx = i;
        break;
      }
    }

    highlightSentence(idx);
    clearSelection();
  }

  // Detect selection changes (mouse + touch)
  function onSelectionChange(){
    const txt = getSelectedTextInReader();
    if (txt) showSelectionBar(txt);
    else hideSelectionBar();
  }
  document.addEventListener("selectionchange", () => {
    // throttled-ish by the browser; keep it simple
    onSelectionChange();
  });

  startFromSelectionBtn.addEventListener("click", setStartFromSelection);
  clearSelectionBtn.addEventListener("click", clearSelection);

  // ===== DOCX =====
  async function docxToText(arrayBuffer){
    if (!window.mammoth) throw new Error("DOCX engine not loaded.");
    const result = await window.mammoth.extractRawText({ arrayBuffer });
    return (result && result.value ? result.value : "")
      .replace(/\n{3,}/g, "\n\n")
      .trim();
  }

  // ===== PDF =====
  async function pdfToText(arrayBuffer){
    if (typeof window.pdfjsLib === "undefined") throw new Error("PDF engine not loaded.");
    window.pdfjsLib.GlobalWorkerOptions.workerSrc =
      "https://cdn.jsdelivr.net/npm/pdfjs-dist@3.4.120/legacy/build/pdf.worker.min.js";

    const bytes = new Uint8Array(arrayBuffer);
    const task = window.pdfjsLib.getDocument({
      data: bytes,
      disableAutoFetch: true,
      disableStream: true,
      disableRange: true,
      stopAtErrors: false,
      verbosity: 0
    });

    task.onPassword = (updatePassword) => {
      const pw = prompt("PDF is password-protected. Enter password:");
      if (pw) updatePassword(pw);
    };

    const pdf = await task.promise;
    let out = [];
    for (let p = 1; p <= pdf.numPages; p++){
      const page = await pdf.getPage(p);
      const tc = await page.getTextContent();
      const pageText = tc.items.map(it => it.str).join(" ");
      out.push(pageText);
    }
    return out.join("\n\n").replace(/\s{2,}/g, " ").trim();
  }

  async function handleFile(f){
    if (!f) return;

    setStatus(fileStatus,
      `Picked:\nName: ${f.name || "(no name)"}\nType: ${f.type || "(blank)"}\nSize: ${(f.size/1024).toFixed(0)} KB`,
      "ok"
    );

    const lower = (f.name || "").toLowerCase();

    try{
      if (lower.endsWith(".docx") || (f.type||"").includes("wordprocessingml")){
        const text = await docxToText(await f.arrayBuffer());
        loadText(text, `DOCX: ${f.name}`);
        setStatus(fileStatus, "Loaded DOCX successfully.", "ok");
        return;
      }

      if (lower.endsWith(".pdf") || (f.type||"").includes("pdf")){
        const text = await pdfToText(await f.arrayBuffer());
        if (!text || text.length < 20){
          setStatus(fileStatus, "PDF opened, but it has no extractable text (likely scanned). OCR is not included in this build.", "warn");
          loadText("", `PDF (no text): ${f.name}`);
        } else {
          loadText(text, `PDF: ${f.name}`);
          setStatus(fileStatus, "Loaded PDF text successfully.", "ok");
        }
        return;
      }

      const raw = await f.text();
      loadText(raw, `File: ${f.name}`);
      setStatus(fileStatus, "Loaded as text.", "ok");
    } catch(err){
      console.error(err);
      setStatus(fileStatus, `Open failed:\n${err?.message || String(err)}`, "danger");
    }
  }

  anyFileInput.addEventListener("change", e => handleFile(e.target.files && e.target.files[0]));
  fileInput.addEventListener("change", e => handleFile(e.target.files && e.target.files[0]));

  // Paste
  document.getElementById("usePaste").addEventListener("click", () => {
    loadText(document.getElementById("pasteBox").value || "", "Pasted text");
  });
  document.getElementById("clearText").addEventListener("click", () => {
    document.getElementById("pasteBox").value = "";
    loadText("", "Cleared");
    setStatus(ttsStatus, "", "ok");
  });

  // ===== Gutenberg =====
  const gbQuery = document.getElementById("gbQuery");
  const gbSearch = document.getElementById("gbSearch");
  const gbStatus = document.getElementById("gbStatus");
  const gbResults = document.getElementById("gbResults");

  function esc(s){ return (s||"").replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

  async function gutenbergSearch(q){
    gbResults.innerHTML = "";
    gbStatus.textContent = "Searching…";
    const url = `https://gutendex.com/books/?search=${encodeURIComponent(q)}`;
    const r = await fetch(url);
    if (!r.ok) throw new Error("Search failed");
    const data = await r.json();
    gbStatus.textContent = `Found ${data.results.length} results (showing up to 10).`;

    const top = data.results.slice(0,10);
    gbResults.innerHTML = top.map(b => {
      const title = esc(b.title);
      const author = esc((b.authors && b.authors[0] && b.authors[0].name) ? b.authors[0].name : "Unknown");
      const txt = b.formats?.["text/plain; charset=utf-8"] || b.formats?.["text/plain"] || "";
      const html = b.formats?.["text/html; charset=utf-8"] || b.formats?.["text/html"] || "";
      const best = txt || html;
      const btn = best ? `<button data-url="${esc(best)}" class="primary" style="margin-top:6px;">Load</button>` : `<div class="muted">No text format available.</div>`;
      return `
        <div style="border:1px solid #2b3150;border-radius:12px;padding:10px;margin-top:10px;background:#0f1220;">
          <div style="font-weight:900;">${title}</div>
          <div class="muted" style="font-size:11px;">${author}</div>
          ${btn}
        </div>
      `;
    }).join("");
  }

  gbSearch.addEventListener("click", async () => {
    const q = (gbQuery.value || "").trim();
    if (!q) return;
    try{ await gutenbergSearch(q); }
    catch(e){ gbStatus.textContent = "Gutenberg search failed. Check your connection."; }
  });

  gbResults.addEventListener("click", async (e) => {
    const btn = e.target.closest("button[data-url]");
    if (!btn) return;
    const url = btn.getAttribute("data-url");
    gbStatus.textContent = "Downloading…";
    try{
      const r = await fetch(url);
      const text = await r.text();
      loadText(text, "Gutenberg book");
      gbStatus.textContent = "Loaded into Reader.";
      setTab("load");
    } catch(e){
      gbStatus.textContent = "Could not download that book format.";
    }
  });

  // ===== TTS (kept as-is for now) =====
  function updatePauseLabel(){
    pauseMsLabel.textContent = `${pauseMs.value} ms`;
  }
  pauseMs.addEventListener("input", updatePauseLabel);
  updatePauseLabel();

  let panelOpen = false;
  fabToggle.addEventListener("click", () => {
    panelOpen = !panelOpen;
    fabPanel.classList.toggle("open", panelOpen);
  });

  function chooseBestVoice(voices){
    if (!voices || !voices.length) return null;
    const pool = voices.filter(v => (v.lang || "").toLowerCase() === "en-us");
    const list = pool.length ? pool : voices;
    const rank = (v) => {
      const name = (v.name || "").toLowerCase();
      let score = 0;
      if ((v.lang || "").toLowerCase() === "en-us") score += 100;
      if (name.includes("samantha")) score += 30;
      if (name.includes("siri")) score += 20;
      if (name.includes("enhanced")) score += 15;
      if (name.includes("premium")) score += 10;
      return score;
    };
    return list.slice().sort((a,b) => rank(b) - rank(a))[0] || null;
  }

  function populateVoices(){
    const vs = speechSynthesis.getVoices();
    if (!vs || !vs.length) return;

    state.voices = vs;
    const sorted = [...vs].sort((a,b) => {
      const aUS = (a.lang || "").toLowerCase() === "en-us";
      const bUS = (b.lang || "").toLowerCase() === "en-us";
      if (aUS !== bUS) return bUS - aUS;
      return (a.name || "").localeCompare(b.name || "");
    });

    voiceSelect.innerHTML = "";
    sorted.forEach(v => {
      const opt = document.createElement("option");
      opt.value = v.name;
      opt.textContent = `${v.name} — ${v.lang}`;
      voiceSelect.appendChild(opt);
    });

    const best = chooseBestVoice(sorted);
    if (best) voiceSelect.value = best.name;
    fabVoice.textContent = best ? `Voice: ${best.name}` : "Voice ready";
  }

  if (typeof speechSynthesis !== "undefined"){
    populateVoices();
    speechSynthesis.onvoiceschanged = populateVoices;
  }

  let speakQueue = [];
  let speaking = false;
  let stopped = false;

  function chunkLongSentence(sentence, maxLen = 220){
    if (sentence.length <= maxLen) return [sentence];
    const chunks = [];
    let s = sentence;
    while (s.length > maxLen){
      let cut = s.lastIndexOf(",", maxLen);
      if (cut < 80) cut = s.lastIndexOf(" ", maxLen);
      if (cut < 80) cut = maxLen;
      chunks.push(s.slice(0, cut + 1).trim());
      s = s.slice(cut + 1).trim();
    }
    if (s) chunks.push(s);
    return chunks;
  }

  function stopSpeak(){
    stopped = true;
    speaking = false;
    speakQueue = [];
    try { speechSynthesis.cancel(); } catch(e){}
    fabIcon.textContent = "▶";
  }

  function speakFromHere(){
    if (!sentenceList.length){
      setStatus(ttsStatus, "No text loaded.", "warn");
      return;
    }

    stopSpeak();
    stopped = false;
    speaking = true;
    fabIcon.textContent = "⏸";

    const voice = state.voices.find(v => v.name === voiceSelect.value) || chooseBestVoice(state.voices);
    const pause = parseInt(pauseMs.value || "250", 10);

    const q = [];
    for (let i = startIndex; i < sentenceList.length; i++){
      const sent = sentenceList[i];
      const chunks = chunkLongSentence(sent, 220);
      for (const c of chunks) q.push(c);
      q.push({ __pause:true, ms: pause });
    }
    speakQueue = q;

    const step = () => {
      if (stopped || !speaking) return;

      if (!speakQueue.length){
        speaking = false;
        fabIcon.textContent = "▶";
        return;
      }

      const item = speakQueue.shift();
      if (item && item.__pause){
        setTimeout(step, item.ms || 250);
        return;
      }

      const u = new SpeechSynthesisUtterance(String(item));
      if (voice) u.voice = voice;
      u.rate = parseFloat(rate.value);
      u.pitch = parseFloat(pitch.value);

      u.onend = () => setTimeout(step, 40);
      u.onerror = () => {
        setStatus(ttsStatus, "Speech error. Try another voice.", "warn");
        speaking = false;
        fabIcon.textContent = "▶";
      };

      try { speechSynthesis.speak(u); }
      catch(e){
        setStatus(ttsStatus, `Speech failed: ${e?.message || String(e)}`, "danger");
        speaking = false;
        fabIcon.textContent = "▶";
      }
    };

    step();
  }

  document.getElementById("speak").addEventListener("click", speakFromHere);
  document.getElementById("pause").addEventListener("click", () => { try{ speechSynthesis.pause(); } catch(e){} fabIcon.textContent="▶"; });
  document.getElementById("resume").addEventListener("click", () => { try{ speechSynthesis.resume(); } catch(e){} fabIcon.textContent="⏸"; });
  document.getElementById("stop").addEventListener("click", stopSpeak);

  // ===== Service worker =====
  if ("serviceWorker" in navigator) {
    window.addEventListener("load", () => {
      navigator.serviceWorker.register("./sw.js").catch(() => {});
    });
  }
</script>

</body>
</html>
