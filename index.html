<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#0b0c10" />
  <title>Pocket Reader</title>
  <link rel="manifest" href="./manifest.webmanifest" />

  <style>
    :root{
      --bg:#0b0c10; --card:#12141b; --panel:#0f1220;
      --stroke:#22263a; --stroke2:#2b3150;
      --text:#e7e7e7; --muted:#aeb3c7; --brand:#2a5bd7; --danger:#b63b3b;
      color-scheme: dark;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    body{ margin:0; background:var(--bg); color:var(--text); }
    .app{ min-height:100vh; display:grid; grid-template-rows:auto auto 1fr; }

    .topbar{
      position:sticky; top:0; z-index:50;
      background:rgba(18,20,27,.92); backdrop-filter: blur(10px);
      border-bottom:1px solid var(--stroke);
      padding:12px 14px; display:flex; align-items:flex-start; gap:10px;
    }
    .logo{ width:34px; height:34px; border-radius:10px;
      background:linear-gradient(135deg, var(--brand), #8ab4ff);
      box-shadow: 0 10px 30px rgba(42,91,215,.25);
      flex:0 0 auto;
      margin-top:2px;
    }
    h1{ margin:0; font-size:16px; }
    .sub{ margin:4px 0 0 0; font-size:12px; color:var(--muted); white-space:pre-wrap; }

    .chipbar{
      padding:10px 12px; display:flex; gap:8px; flex-wrap:wrap;
      border-bottom:1px solid var(--stroke);
      background:rgba(15,18,32,.55);
    }
    .chip{
      border:1px solid var(--stroke2);
      background:rgba(18,20,27,.65);
      color:var(--text);
      padding:8px 12px;
      border-radius:999px;
      font-weight:800;
      cursor:pointer;
      user-select:none;
      font-size:13px;
    }
    .chip.active{ border-color:var(--brand); box-shadow: 0 0 0 3px rgba(42,91,215,.15); }

    .content{
      padding:12px;
      display:grid;
      grid-template-columns: 420px 1fr;
      gap:12px;
    }
    @media (max-width: 980px){ .content{ grid-template-columns: 1fr; } }

    .card{
      background:var(--card);
      border:1px solid var(--stroke);
      border-radius:16px;
      overflow:hidden;
      box-shadow: 0 10px 30px rgba(0,0,0,.25);
    }
    .hd{
      padding:12px;
      display:flex; align-items:center; justify-content:space-between;
      border-bottom:1px solid var(--stroke);
      font-weight:900;
    }
    .bd{ padding:12px; }

    input, select, button, textarea{
      width:100%;
      box-sizing:border-box;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid var(--stroke2);
      background:var(--panel);
      color:var(--text);
      outline:none;
      font-size:14px;
    }
    textarea{ min-height:90px; resize:vertical; }
    button{ cursor:pointer; font-weight:900; }
    .primary{ background:var(--brand); border-color:var(--brand); }
    .ghost{ background:transparent; }
    .row{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    .row > *{ flex:1; }

    .muted{ color:var(--muted); font-size:12px; }
    .status{ margin-top:8px; font-size:12px; color:#9fe6b8; white-space:pre-wrap; }
    .warn{ color:#ffd27d; }
    .dangerText{ color:#ff9f9f; }

    #reader{
      white-space:pre-wrap;
      line-height:1.7;
      font-size:18px;
      padding:16px;
      background:var(--panel);
      border-radius:16px;
      min-height:280px;
      max-height:62vh;
      overflow:auto;
      border:1px solid var(--stroke);
    }

    .playerFab{
      position: fixed; right: 14px; bottom: 14px; z-index: 60;
      display: flex; flex-direction: column; align-items: flex-end; gap: 10px;
    }
    .fabMain{
      border-radius: 999px;
      padding: 12px 14px;
      border: 1px solid var(--stroke2);
      background: rgba(18,20,27,.92);
      backdrop-filter: blur(10px);
      display: flex; align-items: center; gap: 10px;
      box-shadow: 0 14px 40px rgba(0,0,0,.35);
      width:auto;
    }
    .fabPanel{
      width: min(360px, calc(100vw - 28px));
      border-radius: 16px;
      border: 1px solid var(--stroke);
      background: rgba(18,20,27,.92);
      backdrop-filter: blur(10px);
      padding: 12px;
      box-shadow: 0 18px 60px rgba(0,0,0,.45);
      display: none;
    }
    .fabPanel.open{ display: block; }
  </style>
</head>

<body>
<div class="app">
  <div class="topbar">
    <div class="logo"></div>
    <div>
      <h1>Pocket Reader</h1>
      <div class="sub" id="aliveBanner">BUILD v12fix • JS: (starting...) • DOCX: (?) • PDF: (?)</div>
    </div>
  </div>

  <div class="chipbar">
    <div class="chip active" data-tab="load">Load</div>
    <div class="chip" data-tab="gutenberg">Gutenberg</div>
  </div>

  <div class="content">
    <section class="card">
      <div class="hd"><span id="leftTitle">Load</span></div>
      <div class="bd">

        <div class="tab" id="tab-load">
          <div class="muted">Use Any File on iPhone for best reliability.</div>
          <div style="height:10px;"></div>

          <div class="muted">Any File (recommended)</div>
          <input id="anyFileInput" type="file" accept="*/*" />

          <div style="height:10px;"></div>
          <div class="muted">Filtered picker (optional)</div>
          <input id="fileInput" type="file"
            accept=".txt,.text,.md,.html,.htm,.docx,.pdf,application/pdf,application/vnd.openxmlformats-officedocument.wordprocessingml.document" />

          <div id="fileStatus" class="status"></div>

          <div style="height:14px;"></div>
          <div class="muted">Or paste text:</div>
          <textarea id="pasteBox" placeholder="Paste text here..."></textarea>
          <div class="row" style="margin-top:8px;">
            <button id="usePaste" class="primary">Load pasted text</button>
            <button id="clearText" class="ghost">Clear</button>
          </div>
        </div>

        <div class="tab" id="tab-gutenberg" style="display:none;">
          <div class="muted">Search Project Gutenberg (via Gutendex) and load into reader.</div>
          <div style="height:10px;"></div>
          <div class="row">
            <input id="gbQuery" type="text" placeholder="Search title or author" />
            <button id="gbSearch" class="primary" style="width:auto;">Search</button>
          </div>
          <div id="gbStatus" class="status"></div>
          <div id="gbResults" class="status" style="white-space:normal;"></div>
        </div>

      </div>
    </section>

    <section class="card">
      <div class="hd">
        <span id="docLabel">Reader</span>
        <span class="muted" id="modeLabel">mode: text</span>
      </div>
      <div class="bd">
        <div id="reader">Load something, then tap ▶ to speak.</div>
        <div id="ttsStatus" class="status"></div>
      </div>
    </section>
  </div>

  <div class="playerFab">
    <button class="fabMain" id="fabToggle" aria-label="Toggle player">
      <span id="fabIcon">▶</span>
      <span class="muted" id="fabVoice">Voice</span>
    </button>

    <div class="fabPanel" id="fabPanel">
      <select id="voiceSelect"></select>
      <div class="row" style="margin-top:10px;">
        <button id="speak" class="primary" style="width:auto;">▶ Speak</button>
        <button id="pause" class="ghost" style="width:auto;">⏸</button>
        <button id="resume" class="ghost" style="width:auto;">⏵</button>
        <button id="stop" class="ghost" style="width:auto;">■</button>
      </div>
      <div style="height:10px;"></div>
      <div class="muted">Rate</div>
      <input id="rate" type="range" min="0.7" max="1.2" value="1.0" step="0.05" />
      <div style="height:10px;"></div>
      <div class="muted">Pitch</div>
      <input id="pitch" type="range" min="0.8" max="1.2" value="1.0" step="0.05" />
    </div>
  </div>
</div>

<script>
/* =========================
   Self-healing library loader
   ========================= */
function loadScriptSequential(urls, testFn, label){
  return new Promise(async (resolve, reject) => {
    for (const url of urls){
      try{
        await new Promise((res, rej) => {
          const s = document.createElement("script");
          s.src = url;
          s.async = true;
          s.onload = () => res();
          s.onerror = () => rej(new Error("Failed to load: " + url));
          document.head.appendChild(s);
        });
        if (testFn()){
          return resolve(url);
        }
      } catch(e){
        // try next
      }
    }
    reject(new Error(label + " failed to load from all sources."));
  });
}

const banner = document.getElementById("aliveBanner");
function setBanner(jsOk, docxOk, pdfOk){
  banner.textContent = `BUILD v12fix • JS: ${jsOk ? "RUNNING ✅" : "NO ❌"} • DOCX: ${docxOk ? "LOADED ✅" : "MISSING ❌"} • PDF: ${pdfOk ? "LOADED ✅" : "MISSING ❌"}`;
}

setBanner(true, false, false);

/* =========================
   UI wiring
   ========================= */
const chips = [...document.querySelectorAll(".chip")];
const tabs = {
  load: document.getElementById("tab-load"),
  gutenberg: document.getElementById("tab-gutenberg"),
};
const leftTitle = document.getElementById("leftTitle");
function setTab(name){
  chips.forEach(c => c.classList.toggle("active", c.dataset.tab === name));
  Object.entries(tabs).forEach(([k,el]) => el.style.display = (k===name ? "block" : "none"));
  leftTitle.textContent = name.charAt(0).toUpperCase() + name.slice(1);
}
chips.forEach(c => c.addEventListener("click", () => setTab(c.dataset.tab)));

const fileInput = document.getElementById("fileInput");
const anyFileInput = document.getElementById("anyFileInput");
const fileStatus = document.getElementById("fileStatus");

const reader = document.getElementById("reader");
const docLabel = document.getElementById("docLabel");
const modeLabel = document.getElementById("modeLabel");
const ttsStatus = document.getElementById("ttsStatus");

function setStatus(el, msg, kind="ok"){
  el.textContent = msg || "";
  el.className = "status " + (kind==="warn" ? "warn" : (kind==="danger" ? "dangerText" : ""));
}

const state = { textRaw:"", voices:[] };

function loadText(text, label){
  state.textRaw = (text || "").trim();
  docLabel.textContent = label || "Reader";
  modeLabel.textContent = "mode: text";
  reader.textContent = state.textRaw || "No text loaded.";
}

/* =========================
   Library-backed file handlers
   ========================= */
async function docxToText(arrayBuffer){
  if (!window.mammoth) throw new Error("DOCX engine not loaded (mammoth).");
  const result = await window.mammoth.extractRawText({ arrayBuffer });
  return (result && result.value ? result.value : "").replace(/\n{3,}/g, "\n\n").trim();
}

async function pdfToText(arrayBuffer){
  if (typeof window.pdfjsLib === "undefined") throw new Error("PDF engine not loaded (pdfjsLib).");

  // worker
  window.pdfjsLib.GlobalWorkerOptions.workerSrc =
  "https://cdn.jsdelivr.net/npm/pdfjs-dist@3.4.120/legacy/build/pdf.worker.min.js";

  const bytes = new Uint8Array(arrayBuffer);

  const loadingTask = window.pdfjsLib.getDocument({
    data: bytes,
    disableAutoFetch: true,
    disableStream: true,
    disableRange: true,
    stopAtErrors: false,
    verbosity: 0
  });

  loadingTask.onPassword = (updatePassword) => {
    const pw = prompt("PDF is password-protected. Enter password:");
    if (pw) updatePassword(pw);
  };

  const pdf = await loadingTask.promise;

  let out = [];
  for (let p = 1; p <= pdf.numPages; p++){
    const page = await pdf.getPage(p);
    const tc = await page.getTextContent();
    const pageText = tc.items.map(it => it.str).join(" ");
    out.push(pageText);
  }
  return out.join("\n\n").replace(/\s{2,}/g, " ").trim();
}

async function handleFile(f){
  if (!f) return;

  setStatus(fileStatus,
    `Picked:\nName: ${f.name || "(no name)"}\nType: ${f.type || "(blank)"}\nSize: ${(f.size/1024).toFixed(0)} KB`,
    "ok"
  );

  const lower = (f.name || "").toLowerCase();

  try{
    if (lower.endsWith(".docx") || (f.type||"").includes("wordprocessingml")){
      const text = await docxToText(await f.arrayBuffer());
      loadText(text, `DOCX: ${f.name}`);
      setStatus(fileStatus, "Loaded DOCX successfully.", "ok");
      return;
    }

    if (lower.endsWith(".pdf") || (f.type||"").includes("pdf")){
      const text = await pdfToText(await f.arrayBuffer());
      if (!text || text.length < 20){
        setStatus(fileStatus, "PDF opened, but no extractable text (likely scanned). OCR is the next step.", "warn");
        loadText("", `PDF (no text): ${f.name}`);
      } else {
        loadText(text, `PDF: ${f.name}`);
        setStatus(fileStatus, "Loaded PDF text successfully.", "ok");
      }
      return;
    }

    // text fallback
    const raw = await f.text();
    loadText(raw, `File: ${f.name}`);
    setStatus(fileStatus, "Loaded as text.", "ok");
  } catch(err){
    console.error(err);
    setStatus(fileStatus, `Open failed:\n${err?.message || String(err)}`, "danger");
  }
}

anyFileInput.addEventListener("change", e => handleFile(e.target.files && e.target.files[0]));
fileInput.addEventListener("change", e => handleFile(e.target.files && e.target.files[0]));

// Paste
document.getElementById("usePaste").addEventListener("click", () => {
  loadText(document.getElementById("pasteBox").value || "", "Pasted text");
});
document.getElementById("clearText").addEventListener("click", () => {
  document.getElementById("pasteBox").value = "";
  loadText("", "Cleared");
});

/* =========================
   Gutenberg
   ========================= */
const gbQuery = document.getElementById("gbQuery");
const gbSearch = document.getElementById("gbSearch");
const gbStatus = document.getElementById("gbStatus");
const gbResults = document.getElementById("gbResults");

function esc(s){ return (s||"").replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

async function gutenbergSearch(q){
  gbResults.innerHTML = "";
  gbStatus.textContent = "Searching…";
  const url = `https://gutendex.com/books/?search=${encodeURIComponent(q)}`;
  const r = await fetch(url);
  if (!r.ok) throw new Error("Search failed");
  const data = await r.json();
  gbStatus.textContent = `Found ${data.results.length} results (showing up to 10).`;

  const top = data.results.slice(0,10);
  gbResults.innerHTML = top.map(b => {
    const title = esc(b.title);
    const author = esc((b.authors && b.authors[0] && b.authors[0].name) ? b.authors[0].name : "Unknown");
    const txt = b.formats?.["text/plain; charset=utf-8"] || b.formats?.["text/plain"] || "";
    const html = b.formats?.["text/html; charset=utf-8"] || b.formats?.["text/html"] || "";
    const best = txt || html;
    const btn = best ? `<button data-url="${esc(best)}" class="primary" style="margin-top:6px;">Load</button>` : `<div class="muted">No text format available.</div>`;
    return `
      <div style="border:1px solid #2b3150;border-radius:12px;padding:10px;margin-top:10px;background:#0f1220;">
        <div style="font-weight:900;">${title}</div>
        <div class="muted" style="font-size:11px;">${author}</div>
        ${btn}
      </div>
    `;
  }).join("");
}

gbSearch.addEventListener("click", async () => {
  const q = (gbQuery.value || "").trim();
  if (!q) return;
  try{ await gutenbergSearch(q); }
  catch(e){ gbStatus.textContent = "Gutenberg search failed. Check your connection."; }
});

gbResults.addEventListener("click", async (e) => {
  const btn = e.target.closest("button[data-url]");
  if (!btn) return;
  const url = btn.getAttribute("data-url");
  gbStatus.textContent = "Downloading…";
  try{
    const r = await fetch(url);
    const text = await r.text();
    loadText(text, "Gutenberg book");
    gbStatus.textContent = "Loaded into Reader.";
    setTab("load");
  } catch(e){
    gbStatus.textContent = "Could not download that book format.";
  }
});

/* =========================
   TTS
   ========================= */


const voiceSelect = document.getElementById("voiceSelect");
const rate = document.getElementById("rate");
const pitch = document.getElementById("pitch");
const fabToggle = document.getElementById("fabToggle");
const fabPanel = document.getElementById("fabPanel");
const fabVoice = document.getElementById("fabVoice");
const fabIcon = document.getElementById("fabIcon");

let panelOpen = false;
fabToggle.addEventListener("click", () => {
  panelOpen = !panelOpen;
  fabPanel.classList.toggle("open", panelOpen);
});

function chooseBestVoice(voices){
  // Prefer US English, then "Siri" / "Enhanced" style names when present.
  const enUS = voices.filter(v => (v.lang || "").toLowerCase() === "en-us");
  const pool = enUS.length ? enUS : voices;

  const rank = (v) => {
    const name = (v.name || "").toLowerCase();
    let score = 0;
    if ((v.lang || "").toLowerCase() === "en-us") score += 100;
    if (name.includes("siri")) score += 30;
    if (name.includes("enhanced")) score += 25;
    if (name.includes("premium")) score += 20;
    if (name.includes("male")) score += 8; // not reliable, but harmless
    return score;
  };

  return pool.slice().sort((a,b) => rank(b) - rank(a))[0] || null;
}

function populateVoices(){
  const vs = speechSynthesis.getVoices();
  if (!vs || !vs.length) return;

  state.voices = vs;
  voiceSelect.innerHTML = "";

  const sorted = [...vs].sort((a,b) => {
    const aUS = (a.lang || "").toLowerCase() === "en-us";
    const bUS = (b.lang || "").toLowerCase() === "en-us";
    if (aUS !== bUS) return bUS - aUS;
    return (a.name || "").localeCompare(b.name || "");
  });

  sorted.forEach(v => {
    const opt = document.createElement("option");
    opt.value = v.name;
    opt.textContent = `${v.name} — ${v.lang}`;
    voiceSelect.appendChild(opt);
  });

  const best = chooseBestVoice(sorted);
  if (best) voiceSelect.value = best.name;

  fabVoice.textContent = best ? `Voice: ${best.lang}` : "Voice ready";
}

function stopSpeak(){ try{ speechSynthesis.cancel(); } catch(e){} fabIcon.textContent="▶"; }

const pauseMs = document.getElementById("pauseMs");
const pauseMsLabel = document.getElementById("pauseMsLabel");

function updatePauseLabel(){
  if (pauseMsLabel) pauseMsLabel.textContent = `${pauseMs.value} ms`;
}
if (pauseMs) pauseMs.addEventListener("input", updatePauseLabel);
updatePauseLabel();

let speakQueue = [];
let speaking = false;
let stopped = false;

function splitSentences(text){
  const t = (text || "").replace(/\r\n/g, "\n").trim();
  if (!t) return [];
  // Sentence-ish split. Good enough for natural pacing.
  const parts = t.split(/(?<=[.!?])\s+(?=[A-Z0-9“"'\(\[])/g);
  return parts.map(s => s.trim()).filter(Boolean);
}

function chunkLongSentence(sentence, maxLen = 220){
  if (sentence.length <= maxLen) return [sentence];
  const chunks = [];
  let s = sentence;
  while (s.length > maxLen){
    // Try to split at a comma or space near the limit.
    let cut = s.lastIndexOf(",", maxLen);
    if (cut < 80) cut = s.lastIndexOf(" ", maxLen);
    if (cut < 80) cut = maxLen;
    chunks.push(s.slice(0, cut + 1).trim());
    s = s.slice(cut + 1).trim();
  }
  if (s) chunks.push(s);
  return chunks;
}

function stopSpeak(){
  stopped = true;
  speaking = false;
  speakQueue = [];
  try { speechSynthesis.cancel(); } catch(e){}
  fabIcon.textContent = "▶";
}

function speakAll(){
  if (!state.textRaw.trim()){
    setStatus(ttsStatus, "No text loaded.", "warn");
    return;
  }

  stopSpeak(); // clears any prior state
  stopped = false;
  fabIcon.textContent = "⏸";

  const v = state.voices.find(x => x.name === voiceSelect.value) || chooseBestVoice(state.voices);

  // Build queue: sentences, then chunk long ones
  const sentences = splitSentences(state.textRaw);
  const q = [];
  for (const sent of sentences){
    const chunks = chunkLongSentence(sent, 220);
    for (const c of chunks) q.push(c);
    // Add a special pause marker after each sentence
    q.push({ __pause: true, ms: parseInt(pauseMs?.value || "250", 10) });
    // Extra pause if sentence ends a paragraph (simple heuristic)
    if (/\n\s*\n/.test(sent)) q.push({ __pause: true, ms: 350 });
  }
  speakQueue = q;
  speaking = true;

  const speakNext = () => {
    if (stopped || !speaking) return;
    if (!speakQueue.length){
      speaking = false;
      fabIcon.textContent = "▶";
      return;
    }

    const item = speakQueue.shift();

    if (item && item.__pause){
      setTimeout(speakNext, item.ms || 250);
      return;
    }

    const u = new SpeechSynthesisUtterance(String(item));
    if (v) u.voice = v;
    u.rate = parseFloat(rate.value);
    u.pitch = parseFloat(pitch.value);

    u.onend = () => {
      // Small breath between chunks even within a sentence
      setTimeout(speakNext, 40);
    };
    u.onerror = () => {
      setStatus(ttsStatus, "Speech error. Try another voice.", "warn");
      speaking = false;
      fabIcon.textContent = "▶";
    };

    try {
      speechSynthesis.speak(u);
    } catch (e) {
      setStatus(ttsStatus, `Speech failed: ${e?.message || String(e)}`, "danger");
      speaking = false;
      fabIcon.textContent = "▶";
    }
  };

  speakNext();
}

// Keep your existing pause/resume buttons, but make stop use the new stop
document.getElementById("stop").addEventListener("click", stopSpeak);
document.getElementById("speak").addEventListener("click", speakAll);
/* =========================
   Load libraries with fallback CDNs
   ========================= */
(async function initLibraries(){
  try{
    // Mammoth (DOCX)
    await loadScriptSequential(
      [
        "https://cdn.jsdelivr.net/npm/mammoth/mammoth.browser.min.js",
        "https://unpkg.com/mammoth/mammoth.browser.min.js"
      ],
      () => typeof window.mammoth !== "undefined",
      "DOCX engine"
    );
  } catch(e){
    console.warn(e);
  }

   try{
    // PDF.js (legacy build with .js files)
    await loadScriptSequential(
      [
        "https://cdn.jsdelivr.net/npm/pdfjs-dist@3.4.120/legacy/build/pdf.min.js"
      ],
      () => typeof window.pdfjsLib !== "undefined",
      "PDF engine"
    );
  } catch(e){
    console.warn(e);
  }


  setBanner(true, typeof window.mammoth !== "undefined", typeof window.pdfjsLib !== "undefined");
})();
</script>

<script>
  // Service worker registration (kept tiny and safe)
  if ("serviceWorker" in navigator) {
    window.addEventListener("load", () => {
      navigator.serviceWorker.register("./sw.js").catch(() => {});
    });
  }
</script>

</body>
</html>
