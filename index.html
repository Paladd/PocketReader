<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#0b0c10" />
  <title>Pocket Reader</title>

  <link rel="manifest" href="./manifest.webmanifest" />

  <style>
    :root{
      --bg:#0b0c10;
      --card:#12141b;
      --panel:#0f1220;
      --stroke:#22263a;
      --stroke2:#2b3150;
      --text:#e7e7e7;
      --muted:#aeb3c7;
      --brand:#2a5bd7;
      --danger:#b63b3b;
      color-scheme: dark;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    body{ margin:0; background:var(--bg); color:var(--text); }
    .app{ min-height:100vh; display:grid; grid-template-rows:auto auto 1fr; }

    .topbar{
      position:sticky; top:0; z-index:50;
      background:rgba(18,20,27,.9);
      backdrop-filter: blur(10px);
      border-bottom:1px solid var(--stroke);
      padding:12px 14px;
      display:flex; align-items:center; justify-content:space-between; gap:10px;
    }
    .brand{ display:flex; align-items:center; gap:10px; }
    .logo{
      width:34px; height:34px; border-radius:10px;
      background:linear-gradient(135deg, var(--brand), #8ab4ff);
      box-shadow: 0 10px 30px rgba(42,91,215,.25);
    }
    .brand h1{ margin:0; font-size:16px; letter-spacing:.2px; }
    .brand .sub{ margin:2px 0 0 0; font-size:12px; color:var(--muted); }

    .chipbar{
      padding:10px 12px;
      display:flex; gap:8px; flex-wrap:wrap;
      border-bottom:1px solid var(--stroke);
      background:rgba(15,18,32,.5);
    }
    .chip{
      border:1px solid var(--stroke2);
      background:rgba(18,20,27,.65);
      color:var(--text);
      padding:8px 12px;
      border-radius:999px;
      font-weight:800;
      cursor:pointer;
      user-select:none;
      font-size:13px;
    }
    .chip.active{ border-color:var(--brand); box-shadow: 0 0 0 3px rgba(42,91,215,.15); }

    .content{
      padding:12px;
      display:grid;
      grid-template-columns: 420px 1fr;
      gap:12px;
    }
    @media (max-width: 980px){ .content{ grid-template-columns: 1fr; } }

    .card{
      background:var(--card);
      border:1px solid var(--stroke);
      border-radius:16px;
      overflow:hidden;
      box-shadow: 0 10px 30px rgba(0,0,0,.25);
    }
    .card .hd{
      padding:12px;
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      border-bottom:1px solid var(--stroke);
      font-weight:900;
    }
    .card .bd{ padding:12px; }

    input, select, button, textarea{
      width:100%;
      box-sizing:border-box;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid var(--stroke2);
      background:var(--panel);
      color:var(--text);
      outline:none;
      font-size:14px;
    }
    textarea{ min-height:90px; resize:vertical; }
    button{ cursor:pointer; font-weight:900; }
    .primary{ background:var(--brand); border-color:var(--brand); }
    .ghost{ background:transparent; }
    .danger{ background:var(--danger); border-color:var(--danger); }

    .row{ display:flex; gap:8px; flex-wrap:wrap; }
    .row > *{ flex:1; }
    .muted{ color:var(--muted); font-size:12px; }
    .status{ margin-top:8px; font-size:12px; color:#9fe6b8; white-space:pre-wrap; }
    .warn{ color:#ffd27d; }
    .dangerText{ color:#ff9f9f; }

    #reader{
      white-space:pre-wrap;
      line-height:1.7;
      font-size:18px;
      padding:16px;
      background:var(--panel);
      border-radius:16px;
      min-height:280px;
      max-height:62vh;
      overflow:auto;
      border:1px solid var(--stroke);
    }
    @media (max-width:980px){ #reader{ max-height:52vh; } }
    .sent{ padding:.12em 0; border-radius:8px; cursor:pointer; }
    .sent:hover{ outline:1px solid rgba(174,179,199,.25); }
    .sent.active{ background: rgba(42,91,215,.22); outline:1px solid rgba(42,91,215,.45); }

    .progressWrap{ margin-top:10px; }
    .progressBar{
      width:100%; height:10px; border-radius:999px;
      background:var(--panel);
      border:1px solid var(--stroke2);
      overflow:hidden;
    }
    .progressFill{ height:100%; width:0%; background:var(--brand); }

    /* Floating player */
    .playerFab{
      position: fixed;
      right: 14px;
      bottom: 14px;
      z-index: 60;
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 10px;
    }
    .fabMain{
      width: auto;
      border-radius: 999px;
      padding: 12px 14px;
      border: 1px solid var(--stroke2);
      background: rgba(18,20,27,.92);
      backdrop-filter: blur(10px);
      display: flex;
      align-items: center;
      gap: 10px;
      box-shadow: 0 14px 40px rgba(0,0,0,.35);
    }
    .fabMain:active{ transform: scale(0.99); }
    .fabPct{ font-size: 12px; color: var(--muted); font-weight: 900; }
    .fabPanel{
      width: min(360px, calc(100vw - 28px));
      border-radius: 16px;
      border: 1px solid var(--stroke);
      background: rgba(18,20,27,.92);
      backdrop-filter: blur(10px);
      padding: 12px;
      box-shadow: 0 18px 60px rgba(0,0,0,.45);
      display: none;
    }
    .fabPanel.open{ display: block; }
    .hideFab .fabMain{ opacity: 0.15; }
    .hideFab .fabMain:hover{ opacity: 1; }

    /* OCR preview */
    .previewImg{
      width:100%;
      border-radius:16px;
      border:1px solid var(--stroke);
      background:var(--panel);
      max-height:220px;
      object-fit:contain;
    }
  </style>

  <!-- EPUB.js -->
  <script src="https://unpkg.com/epubjs/dist/epub.min.js"></script>
  <!-- DOCX -> text (Mammoth) -->
  <script src="https://unpkg.com/mammoth/mammoth.browser.min.js"></script>
  <!-- PDF.js -->
  <script src="https://unpkg.com/pdfjs-dist@4.10.38/build/pdf.min.js"></script>
  <!-- OCR (Tesseract.js) -->
  <script src="https://unpkg.com/tesseract.js@5.1.0/dist/tesseract.min.js"></script>
</head>

<body>
<div class="app">
  <div class="topbar">
    <div class="brand">
      <div class="logo" aria-hidden="true"></div>
      <div>
        <h1>Pocket Reader</h1>
        <div class="sub">DOCX + PDF + EPUB + OCR + Read Aloud</div>
      </div>
    </div>
  </div>

  <div class="chipbar">
    <div class="chip active" data-tab="load">Load</div>
    <div class="chip" data-tab="ocr">OCR</div>
    <div class="chip" data-tab="gutenberg">Gutenberg</div>
    <div class="chip" data-tab="epub">EPUB</div>
    <div class="chip" data-tab="tips">Tips</div>
  </div>

  <div class="content">
    <section class="card">
      <div class="hd"><span id="leftTitle">Load</span></div>
      <div class="bd">

        <!-- LOAD -->
        <div class="tab" id="tab-load">
          <div class="muted">Supports .txt, .md, .html, .epub, .docx, .pdf</div>
          <div style="height:10px;"></div>

          <input id="fileInput" type="file"
            accept=".txt,.text,.md,.html,.htm,.epub,.docx,.pdf,application/pdf,application/vnd.openxmlformats-officedocument.wordprocessingml.document,application/epub+zip" />
          <div id="fileStatus" class="status"></div>

          <div style="height:14px;"></div>
          <div class="muted">Or paste text:</div>
          <textarea id="pasteBox" placeholder="Paste text here..."></textarea>

          <div class="row" style="margin-top:8px;">
            <button id="usePaste" class="primary">Load pasted text</button>
            <button id="clearText">Clear</button>
          </div>
        </div>

        <!-- OCR -->
        <div class="tab" id="tab-ocr" style="display:none;">
          <div class="muted">
            OCR is best for photos/screenshots and single pages. Whole scanned PDFs on iPhone will be slow.
          </div>
          <div style="height:10px;"></div>

          <input id="imgInput" type="file" accept="image/*,.png,.jpg,.jpeg,.webp" />
          <div style="height:10px;"></div>

          <div class="row">
            <select id="ocrLang">
              <option value="eng" selected>English</option>
              <option value="spa">Spanish</option>
              <option value="fra">French</option>
              <option value="deu">German</option>
            </select>
            <button id="runOcr" class="primary">Run OCR</button>
          </div>

          <div style="height:10px;"></div>
          <img id="ocrPreview" class="previewImg" alt="OCR preview" style="display:none;" />

          <div id="ocrStatus" class="status"></div>

          <div class="row" style="margin-top:8px;">
            <button id="ocrToReader" class="ghost">Load OCR text into Reader</button>
            <button id="ocrSpeak" class="primary">Load + Speak</button>
          </div>
        </div>

        <!-- GUTENBERG -->
        <div class="tab" id="tab-gutenberg" style="display:none;">
          <div class="muted">Search Project Gutenberg (via Gutendex).</div>
          <div style="height:10px;"></div>

          <div class="row">
            <input id="q" placeholder="Search title/author (e.g., Moby Dick, Austen)" />
            <button id="searchBtn" class="primary">Search</button>
          </div>

          <div style="height:10px;"></div>
          <div class="row">
            <select id="lang">
              <option value="">Any language</option>
              <option value="en" selected>English</option>
              <option value="fr">French</option>
              <option value="de">German</option>
              <option value="es">Spanish</option>
            </select>
            <select id="maxResults">
              <option>10</option>
              <option selected>20</option>
              <option>40</option>
            </select>
          </div>

          <div id="searchStatus" class="status"></div>
          <div id="results"></div>
        </div>

        <!-- EPUB -->
        <div class="tab" id="tab-epub" style="display:none;">
          <div class="muted">When an EPUB is loaded, chapters show here.</div>
          <div style="height:10px;"></div>

          <label class="muted" style="display:flex; gap:8px; align-items:center;">
            <input id="autoPlayEpub" type="checkbox" style="width:auto;" />
            Auto-play next chapter
          </label>

          <div class="row" style="margin-top:8px;">
            <button id="prevChapter" class="ghost">◀ Prev</button>
            <button id="nextChapter" class="ghost">Next ▶</button>
          </div>

          <div class="toc" id="toc"></div>
          <div id="epubStatus" class="status"></div>
        </div>

        <!-- TIPS -->
        <div class="tab" id="tab-tips" style="display:none;">
          <div class="muted" style="line-height:1.6;">
            <b>Scanned PDFs:</b> You need OCR. For best results, screenshot a page and OCR the image.<br/><br/>
            <b>If updates don’t show:</b> you’re cached. Bump the service worker cache version and reopen with ?v=4.<br/><br/>
            <b>Best voices:</b> Settings → Accessibility → Spoken Content → Voices → download a high quality US male voice.
          </div>
        </div>

      </div>
    </section>

    <section class="card">
      <div class="hd">
        <span id="docLabel">Reader</span>
        <span class="muted" id="modeLabel">mode: text</span>
      </div>
      <div class="bd">
        <div class="muted">Tap a sentence to jump.</div>

        <div class="progressWrap">
          <div class="progressBar"><div id="progressFill" class="progressFill"></div></div>
          <div id="progressText" class="muted" style="margin-top:6px;">0%</div>
        </div>

        <div style="height:10px;"></div>
        <div id="reader">Load something, then tap ▶ to speak.</div>

        <div id="ttsStatus" class="status"></div>
      </div>
    </section>
  </div>

  <!-- Floating player -->
  <div class="playerFab" id="playerFab">
    <button class="fabMain" id="fabToggle" aria-label="Toggle player">
      <span id="fabIcon">▶</span>
      <span id="fabPct" class="fabPct">0%</span>
    </button>

    <div class="fabPanel" id="fabPanel" aria-hidden="true">
      <div class="row" style="gap:8px; margin-bottom:10px;">
        <select id="voiceSelect" aria-label="Voice"></select>
      </div>

      <div class="row" style="gap:8px;">
        <button id="speak" class="primary" style="width:auto;">▶ Speak</button>
        <button id="pause" class="ghost" style="width:auto;">⏸</button>
        <button id="resume" class="ghost" style="width:auto;">⏵</button>
        <button id="stop" class="danger" style="width:auto;">■</button>
      </div>

      <div class="row" style="gap:12px; margin-top:10px; align-items:center;">
        <label class="muted" style="display:flex; gap:8px; align-items:center; flex:1;">
          <input id="highlightToggle" type="checkbox" style="width:auto;" checked />
          Highlight
        </label>
        <label class="muted" style="display:flex; gap:8px; align-items:center; flex:1;">
          <input id="setStartMode" type="checkbox" style="width:auto;" />
          Set Start Here
        </label>
      </div>

      <div style="height:10px;"></div>
      <div class="muted">Rate</div>
      <input id="rate" type="range" min="0.7" max="1.2" value="1.0" step="0.05" />

      <div style="height:10px;"></div>
      <div class="muted">Pitch</div>
      <input id="pitch" type="range" min="0.8" max="1.2" value="1.0" step="0.05" />
    </div>
  </div>
</div>

<div id="epubHidden" style="position:absolute; left:-99999px; top:-99999px; width:900px; height:700px;"></div>

<script>
  // Tabs
  const chips = [...document.querySelectorAll(".chip")];
  const tabs = {
    load: document.getElementById("tab-load"),
    ocr: document.getElementById("tab-ocr"),
    gutenberg: document.getElementById("tab-gutenberg"),
    epub: document.getElementById("tab-epub"),
    tips: document.getElementById("tab-tips"),
  };
  const leftTitle = document.getElementById("leftTitle");
  function setTab(name){
    chips.forEach(c => c.classList.toggle("active", c.dataset.tab === name));
    Object.entries(tabs).forEach(([k,el]) => el.style.display = (k===name ? "block" : "none"));
    leftTitle.textContent = name.charAt(0).toUpperCase() + name.slice(1);
  }
  chips.forEach(c => c.addEventListener("click", () => setTab(c.dataset.tab)));

  // DOM
  const fileInput = document.getElementById("fileInput");
  const fileStatus = document.getElementById("fileStatus");
  const pasteBox = document.getElementById("pasteBox");
  const usePaste = document.getElementById("usePaste");
  const clearText = document.getElementById("clearText");

  const reader = document.getElementById("reader");
  const docLabel = document.getElementById("docLabel");
  const modeLabel = document.getElementById("modeLabel");

  const voiceSelect = document.getElementById("voiceSelect");
  const rate = document.getElementById("rate");
  const pitch = document.getElementById("pitch");
  const highlightToggle = document.getElementById("highlightToggle");
  const setStartMode = document.getElementById("setStartMode");

  const speakBtn = document.getElementById("speak");
  const pauseBtn = document.getElementById("pause");
  const resumeBtn = document.getElementById("resume");
  const stopBtn = document.getElementById("stop");
  const ttsStatus = document.getElementById("ttsStatus");

  const progressFill = document.getElementById("progressFill");
  const progressText = document.getElementById("progressText");

  // OCR DOM
  const imgInput = document.getElementById("imgInput");
  const ocrLang = document.getElementById("ocrLang");
  const runOcr = document.getElementById("runOcr");
  const ocrPreview = document.getElementById("ocrPreview");
  const ocrStatus = document.getElementById("ocrStatus");
  const ocrToReader = document.getElementById("ocrToReader");
  const ocrSpeak = document.getElementById("ocrSpeak");
  let ocrText = "";
  let ocrImageURL = "";

  // Gutenberg DOM
  const q = document.getElementById("q");
  const searchBtn = document.getElementById("searchBtn");
  const searchStatus = document.getElementById("searchStatus");
  const results = document.getElementById("results");
  const lang = document.getElementById("lang");
  const maxResults = document.getElementById("maxResults");

  // EPUB DOM
  const tocEl = document.getElementById("toc");
  const epubStatus = document.getElementById("epubStatus");
  const autoPlayEpub = document.getElementById("autoPlayEpub");
  const prevChapterBtn = document.getElementById("prevChapter");
  const nextChapterBtn = document.getElementById("nextChapter");
  const epubHidden = document.getElementById("epubHidden");

  // Floating player
  const fabToggle = document.getElementById("fabToggle");
  const fabPanel = document.getElementById("fabPanel");
  const fabIcon = document.getElementById("fabIcon");
  const fabPct = document.getElementById("fabPct");

  // PDF worker
  if (window.pdfjsLib) {
    pdfjsLib.GlobalWorkerOptions.workerSrc =
      "https://unpkg.com/pdfjs-dist@4.10.38/build/pdf.worker.min.js";
  }

  // Storage
  const STORAGE = {
    lastMode: "pr_lastMode",
    lastText: "pr_lastText",
    lastLabel: "pr_lastLabel",
    lastRate: "pr_rate",
    lastPitch: "pr_pitch",
    lastVoice: "pr_voice",
    highlight: "pr_highlight",
    setStartMode: "pr_setStartMode",
    autoPlay: "pr_autoplay_epub",
    lastEpubHref: "pr_lastEpubHref",
    resumeIdx: "pr_resumeSentenceIdx"
  };

  // State
  const state = {
    mode: "text",
    label: "Loaded",
    textRaw: "",
    sentences: [],
    sentenceEls: [],
    currentSentenceIndex: 0,
    voices: [],
    speaking: false,

    epub: null,
    epubTocFlat: [],
    activeTocIndex: -1
  };

  // Helpers
  function setStatus(el, msg, kind="ok"){
    el.textContent = msg || "";
    el.className = "status " + (kind==="warn" ? "warn" : (kind==="danger" ? "dangerText" : ""));
  }
  function setDocTitle(label, mode){
    docLabel.textContent = label || "Reader";
    modeLabel.textContent = "mode: " + (mode || "text");
  }
  function stripHtmlIfNeeded(text, filenameLower=""){
    if (!text) return "";
    const looksHtml =
      filenameLower.endsWith(".html") ||
      filenameLower.endsWith(".htm") ||
      /<\/(p|div|h1|h2|h3|br|body|html)>/i.test(text);
    if (!looksHtml) return text;
    const tmp = document.createElement("div");
    tmp.innerHTML = text;
    tmp.querySelectorAll("script,style").forEach(el => el.remove());
    const out = (tmp.textContent || tmp.innerText || "").trim();
    return out.replace(/\n{3,}/g, "\n\n");
  }
  function htmlToText(html){
    const tmp = document.createElement("div");
    tmp.innerHTML = html || "";
    tmp.querySelectorAll("script,style").forEach(el => el.remove());
    const text = (tmp.textContent || tmp.innerText || "").trim();
    return text.replace(/\n{3,}/g, "\n\n");
  }
  function splitIntoSentences(text){
    const t = (text || "").replace(/\r\n/g, "\n").trim();
    if (!t) return [];
    const parts = t.split(/(?<=[.!?])\s+(?=[A-Z0-9“"'\(\[])/g);
    return parts.map(s => s.trim()).filter(Boolean);
  }
  function renderReaderWithSentences(sentences){
    reader.innerHTML = "";
    state.sentenceEls = [];
    if (!sentences.length) { reader.textContent = "No text loaded."; return; }
    const frag = document.createDocumentFragment();
    sentences.forEach((s, idx) => {
      const span = document.createElement("span");
      span.className = "sent";
      span.dataset.idx = String(idx);
      span.textContent = s + " ";
      state.sentenceEls[idx] = span;
      frag.appendChild(span);
    });
    reader.appendChild(frag);
  }
  function clearActiveHighlight(){
    for (const el of state.sentenceEls) if (el) el.classList.remove("active");
  }
  function setActiveHighlight(i){
    if (!highlightToggle.checked) return;
    clearActiveHighlight();
    const el = state.sentenceEls[i];
    if (!el) return;
    el.classList.add("active");
    try { el.scrollIntoView({ block:"center", behavior:"smooth" }); } catch(e){}
  }
  function updateProgress(){
    const total = state.sentences.length || 0;
    const idx = Math.max(0, Math.min(state.currentSentenceIndex, Math.max(0, total-1)));
    const pct = total ? Math.round((idx / total) * 100) : 0;
    progressFill.style.width = pct + "%";
    progressText.textContent = total ? `${pct}% (sentence ${idx+1} of ${total})` : "0%";
    if (fabPct) fabPct.textContent = total ? `${pct}%` : "0%";
  }

  // TTS
  function stopSpeaking(){
    try { speechSynthesis.cancel(); } catch(e) {}
    state.speaking = false;
    setStatus(ttsStatus, "");
    clearActiveHighlight();
    if (fabIcon) fabIcon.textContent = "▶";
  }
  function getSelectedVoice(){
    const name = voiceSelect.value;
    return state.voices.find(v => v.name === name) || null;
  }
  function speakFrom(index){
    if (!state.textRaw.trim()) { setStatus(ttsStatus, "No text loaded.", "warn"); return; }
    stopSpeaking();
    state.speaking = true;
    state.currentSentenceIndex = Math.max(0, Math.min(index, state.sentences.length - 1));
    localStorage.setItem(STORAGE.resumeIdx, String(state.currentSentenceIndex));
    updateProgress();
    if (fabIcon) fabIcon.textContent = "⏸";
    speakNextSentence();
  }
  function speakNextSentence(){
    if (!state.speaking) return;

    if (state.currentSentenceIndex >= state.sentences.length){
      state.speaking = false;
      setStatus(ttsStatus, "Finished.", "ok");
      clearActiveHighlight();
      if (fabIcon) fabIcon.textContent = "▶";
      return;
    }

    const s = state.sentences[state.currentSentenceIndex];
    const voice = getSelectedVoice();

    setActiveHighlight(state.currentSentenceIndex);
    updateProgress();

    const u = new SpeechSynthesisUtterance(s);
    if (voice) u.voice = voice;
    u.rate = parseFloat(rate.value);
    u.pitch = parseFloat(pitch.value);

    u.onstart = () => setStatus(ttsStatus, `Speaking ${state.currentSentenceIndex+1}/${state.sentences.length} • ${state.label}`, "ok");
    u.onerror = () => {
      state.speaking = false;
      setStatus(ttsStatus, "Speech error. Try a different voice.", "warn");
      clearActiveHighlight();
      if (fabIcon) fabIcon.textContent = "▶";
    };
    u.onend = () => {
      state.currentSentenceIndex += 1;
      localStorage.setItem(STORAGE.resumeIdx, String(state.currentSentenceIndex));
      speakNextSentence();
    };

    speechSynthesis.speak(u);
  }

  function populateVoices(){
    const vs = speechSynthesis.getVoices();
    if (!vs || !vs.length) return;
    state.voices = vs;
    voiceSelect.innerHTML = "";
    const sorted = [...vs].sort((a,b) => {
      const aUS = (a.lang || "").toLowerCase().includes("en-us");
      const bUS = (b.lang || "").toLowerCase().includes("en-us");
      if (aUS !== bUS) return bUS - aUS;
      return (a.name || "").localeCompare(b.name || "");
    });
    for (const v of sorted){
      const opt = document.createElement("option");
      opt.value = v.name;
      opt.textContent = `${v.name} — ${v.lang}${v.default ? " (default)" : ""}`;
      voiceSelect.appendChild(opt);
    }
    const saved = localStorage.getItem(STORAGE.lastVoice);
    const preferred = saved && sorted.some(v => v.name === saved)
      ? saved
      : (sorted.find(v => (v.lang || "").toLowerCase().includes("en-us"))?.name || sorted[0]?.name);
    if (preferred) voiceSelect.value = preferred;
  }

  function loadText(text, label, mode="text"){
    stopSpeaking();
    state.mode = mode;
    state.label = label || "Loaded";
    state.textRaw = text || "";
    state.sentences = splitIntoSentences(state.textRaw);

    let idx = parseInt(localStorage.getItem(STORAGE.resumeIdx) || "0", 10);
    if (Number.isNaN(idx) || idx < 0 || idx >= state.sentences.length) idx = 0;
    state.currentSentenceIndex = idx;

    renderReaderWithSentences(state.sentences);
    setDocTitle(state.label, state.mode);

    localStorage.setItem(STORAGE.lastMode, state.mode);
    localStorage.setItem(STORAGE.lastText, state.textRaw);
    localStorage.setItem(STORAGE.lastLabel, state.label);

    if (!state.textRaw.trim()){
      setStatus(fileStatus, "No text loaded.", "warn");
    } else {
      setStatus(fileStatus, `${state.label} (${state.textRaw.length.toLocaleString()} chars)`, "ok");
    }

    setActiveHighlight(state.currentSentenceIndex);
    updateProgress();
  }

  // DOCX
  async function docxToText(arrayBuffer){
    const result = await mammoth.extractRawText({ arrayBuffer });
    return (result && result.value ? result.value : "").replace(/\n{3,}/g, "\n\n").trim();
  }

  // PDF
  async function pdfToText(arrayBuffer){
    if (!window.pdfjsLib) throw new Error("PDF engine not loaded");
    const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer });
    const pdf = await loadingTask.promise;
    let out = [];
    for (let p = 1; p <= pdf.numPages; p++){
      const page = await pdf.getPage(p);
      const tc = await page.getTextContent();
      const pageText = tc.items.map(it => it.str).join(" ");
      out.push(pageText);
    }
    return out.join("\n\n").replace(/\s{2,}/g, " ").trim();
  }

  // EPUB (kept minimal here)
  function flattenToc(toc, out=[]){
    for (const item of (toc || [])){
      out.push({ label: item.label || "(untitled)", href: item.href });
      if (item.subitems && item.subitems.length) flattenToc(item.subitems, out);
    }
    return out;
  }
  function updateTocActive(){
    [...tocEl.querySelectorAll("button")].forEach(b => {
      const idx = parseInt(b.dataset.idx, 10);
      b.classList.toggle("active", idx === state.activeTocIndex);
    });
  }
  async function loadEpubChapterByIndex(idx){
    if (!state.epub || !state.epubTocFlat.length) return;
    if (idx < 0 || idx >= state.epubTocFlat.length) return;
    state.activeTocIndex = idx;
    updateTocActive();
    const item = state.epubTocFlat[idx];
    setStatus(epubStatus, `Loading: ${item.label}…`, "ok");
    const section = await state.epub.section(item.href);
    const contents = await section.load(state.epub.load.bind(state.epub));
    const html = contents?.document ? contents.document.documentElement.outerHTML : "";
    const text = htmlToText(html);
    localStorage.setItem(STORAGE.resumeIdx, "0");
    loadText(text, `EPUB: ${item.label}`, "epub");
    setStatus(epubStatus, `Loaded: ${item.label}`, "ok");
  }
  async function loadEpubFromArrayBuffer(buf, label){
    setStatus(epubStatus, "Loading EPUB…", "ok");
    tocEl.innerHTML = "";
    state.epubTocFlat = [];
    state.activeTocIndex = -1;
    state.epub = ePub(buf);
    state.epub.renderTo(epubHidden, { width:900, height:700 });
    const nav = await state.epub.loaded.navigation;
    state.epubTocFlat = flattenToc(nav?.toc || [], []);
    tocEl.innerHTML = "";
    state.epubTocFlat.forEach((it, idx) => {
      const b = document.createElement("button");
      b.textContent = it.label || "(untitled)";
      b.dataset.idx = String(idx);
      b.addEventListener("click", () => loadEpubChapterByIndex(idx));
      tocEl.appendChild(b);
    });
    setStatus(fileStatus, label, "ok");
    setTab("epub");
    if (state.epubTocFlat.length) await loadEpubChapterByIndex(0);
  }
  prevChapterBtn.addEventListener("click", () => loadEpubChapterByIndex(Math.max(0, state.activeTocIndex - 1)));
  nextChapterBtn.addEventListener("click", () => loadEpubChapterByIndex(Math.min(state.epubTocFlat.length - 1, state.activeTocIndex + 1)));

  // Reader interactions
  reader.addEventListener("click", (e) => {
    const sent = e.target.closest(".sent");
    if (!sent) return;
    const idx = parseInt(sent.dataset.idx, 10);
    if (Number.isNaN(idx)) return;
    state.currentSentenceIndex = idx;
    localStorage.setItem(STORAGE.resumeIdx, String(idx));
    setActiveHighlight(idx);
    updateProgress();
    if (!setStartMode.checked) speakFrom(idx);
    else setStatus(ttsStatus, "Start point set. Press Speak.", "ok");
  });

  // Floating toggle + hide-on-scroll
  let panelOpen = false;
  fabToggle.addEventListener("click", () => {
    panelOpen = !panelOpen;
    fabPanel.classList.toggle("open", panelOpen);
    fabPanel.setAttribute("aria-hidden", panelOpen ? "false" : "true");
  });
  let scrollTimer = null;
  reader.addEventListener("scroll", () => {
    document.body.classList.add("hideFab");
    if (scrollTimer) clearTimeout(scrollTimer);
    scrollTimer = setTimeout(() => document.body.classList.remove("hideFab"), 420);
  });

  // File loading
  fileInput.addEventListener("change", async (e) => {
    const f = e.target.files && e.target.files[0];
    if (!f) return;
    const name = (f.name || "file").toLowerCase();
    setStatus(fileStatus, `Loading: ${f.name}…`, "ok");

    try{
      if (name.endsWith(".epub") || f.type === "application/epub+zip"){
        localStorage.setItem(STORAGE.resumeIdx, "0");
        await loadEpubFromArrayBuffer(await f.arrayBuffer(), `Loaded EPUB: ${f.name}`);
        return;
      }

      if (name.endsWith(".docx") || f.type === "application/vnd.openxmlformats-officedocument.wordprocessingml.document"){
        const text = await docxToText(await f.arrayBuffer());
        localStorage.setItem(STORAGE.resumeIdx, "0");
        loadText(text, `Loaded DOCX: ${f.name}`, "text");
        return;
      }

      if (name.endsWith(".pdf") || f.type === "application/pdf"){
        const text = await pdfToText(await f.arrayBuffer());
        if (!text || text.length < 10) {
          setStatus(fileStatus, "This PDF looks scanned (image-only). Use the OCR tab with a screenshot/page image.", "warn");
          loadText("", "PDF (no extractable text)", "text");
        } else {
          localStorage.setItem(STORAGE.resumeIdx, "0");
          loadText(text, `Loaded PDF: ${f.name}`, "text");
        }
        return;
      }

      const raw = await f.text();
      const cleaned = stripHtmlIfNeeded(raw, name);
      localStorage.setItem(STORAGE.resumeIdx, "0");
      loadText(cleaned, `Loaded file: ${f.name}`, "text");
    } catch(err){
      console.error(err);
      setStatus(fileStatus, "Could not read that file.", "warn");
    } finally {
      fileInput.value = "";
    }
  });

  usePaste.addEventListener("click", () => {
    localStorage.setItem(STORAGE.resumeIdx, "0");
    loadText(pasteBox.value || "", "Loaded pasted text", "text");
  });
  clearText.addEventListener("click", () => {
    pasteBox.value = "";
    localStorage.setItem(STORAGE.resumeIdx, "0");
    loadText("", "Cleared", "text");
  });

  // OCR
  imgInput.addEventListener("change", async (e) => {
    const f = e.target.files && e.target.files[0];
    if (!f) return;
    if (ocrImageURL) URL.revokeObjectURL(ocrImageURL);
    ocrImageURL = URL.createObjectURL(f);
    ocrPreview.src = ocrImageURL;
    ocrPreview.style.display = "block";
    ocrText = "";
    setStatus(ocrStatus, "Image loaded. Tap Run OCR.", "ok");
  });

  runOcr.addEventListener("click", async () => {
    if (!ocrImageURL){
      setStatus(ocrStatus, "Upload an image first.", "warn");
      return;
    }
    if (!window.Tesseract){
      setStatus(ocrStatus, "OCR engine not loaded (cached build or blocked). Refresh with ?v=4 and try again.", "warn");
      return;
    }

    setStatus(ocrStatus, "OCR running… (this can take 15–60 seconds on iPhone)", "ok");

    try{
      const langCode = ocrLang.value;
      const { data } = await Tesseract.recognize(ocrImageURL, langCode, {
        logger: m => {
          if (m.status && typeof m.progress === "number") {
            const pct = Math.round(m.progress * 100);
            setStatus(ocrStatus, `OCR: ${m.status} • ${pct}%`, "ok");
          }
        }
      });

      ocrText = (data && data.text ? data.text : "").trim();
      if (!ocrText) {
        setStatus(ocrStatus, "OCR finished but found little or no text. Try a sharper/closer photo.", "warn");
      } else {
        setStatus(ocrStatus, `OCR complete. ${ocrText.length.toLocaleString()} characters found.`, "ok");
      }
    } catch (err){
      console.error(err);
      setStatus(ocrStatus, "OCR failed. Try a smaller image or screenshot a single page.", "warn");
    }
  });

  ocrToReader.addEventListener("click", () => {
    if (!ocrText) { setStatus(ocrStatus, "Run OCR first.", "warn"); return; }
    localStorage.setItem(STORAGE.resumeIdx, "0");
    loadText(ocrText, "OCR text", "text");
  });

  ocrSpeak.addEventListener("click", () => {
    if (!ocrText) { setStatus(ocrStatus, "Run OCR first.", "warn"); return; }
    localStorage.setItem(STORAGE.resumeIdx, "0");
    loadText(ocrText, "OCR text", "text");
    speakFrom(0);
  });

  // Controls
  speakBtn.addEventListener("click", () => speakFrom(state.currentSentenceIndex || 0));
  pauseBtn.addEventListener("click", () => { try { speechSynthesis.pause(); } catch(e){} if (fabIcon) fabIcon.textContent = "▶"; });
  resumeBtn.addEventListener("click", () => { try { speechSynthesis.resume(); } catch(e){} if (fabIcon) fabIcon.textContent = "⏸"; });
  stopBtn.addEventListener("click", stopSpeaking);

  voiceSelect.addEventListener("change", () => localStorage.setItem(STORAGE.lastVoice, voiceSelect.value));
  rate.addEventListener("change", () => localStorage.setItem(STORAGE.lastRate, String(rate.value)));
  pitch.addEventListener("change", () => localStorage.setItem(STORAGE.lastPitch, String(pitch.value)));
  highlightToggle.addEventListener("change", () => {
    localStorage.setItem(STORAGE.highlight, highlightToggle.checked ? "1" : "0");
    if (!highlightToggle.checked) clearActiveHighlight();
    else setActiveHighlight(state.currentSentenceIndex);
  });
  setStartMode.addEventListener("change", () => localStorage.setItem(STORAGE.setStartMode, setStartMode.checked ? "1" : "0"));

  // Gutenberg (minimal)
  async function gutendexSearch(query, language, limit){
    const params = new URLSearchParams();
    params.set("search", query);
    if (language) params.set("languages", language);
    params.set("page", "1");
    const url = `https://gutendex.com/books?${params.toString()}`;
    const res = await fetch(url);
    if (!res.ok) throw new Error("Search failed");
    const data = await res.json();
    return (data.results || []).slice(0, limit);
  }
  function pickBestTextUrl(formats){
    const keys = Object.keys(formats || {});
    const prefer = ["text/plain; charset=utf-8","text/plain; charset=us-ascii","text/plain"];
    for (const p of prefer){
      const hit = keys.find(k => k.toLowerCase().startsWith(p));
      if (hit) return formats[hit];
    }
    return null;
  }
  function pickEpubUrl(formats){
    const keys = Object.keys(formats || {});
    const hit = keys.find(k => k.toLowerCase().includes("application/epub+zip"));
    return hit ? formats[hit] : null;
  }
  async function doSearch(){
    const query = (q.value || "").trim();
    if (!query){ setStatus(searchStatus, "Type a search query.", "warn"); return; }
    results.innerHTML = "";
    setStatus(searchStatus, "Searching…", "ok");

    const items = await gutendexSearch(query, lang.value, parseInt(maxResults.value,10));
    if (!items.length){
      results.innerHTML = `<div class="muted">No results.</div>`;
      return;
    }

    items.forEach(b => {
      const title = b.title || "Untitled";
      const authors = (b.authors || []).map(a => a.name).join(", ") || "Unknown author";
      const textUrl = pickBestTextUrl(b.formats);
      const epubUrl = pickEpubUrl(b.formats);

      const div = document.createElement("div");
      div.className = "result";
      div.innerHTML = `
        <div class="title">${title}</div>
        <div class="meta">${authors}</div>
        <div class="pills">
          ${textUrl ? `<a class="pill" href="${textUrl}" target="_blank" rel="noopener">Download text</a>` : ""}
          ${epubUrl ? `<a class="pill" href="${epubUrl}" target="_blank" rel="noopener">Download EPUB</a>` : ""}
        </div>
      `;
      results.appendChild(div);
    });

    setStatus(searchStatus, `Found ${items.length} result(s).`, "ok");
  }
  searchBtn.addEventListener("click", () => { setTab("gutenberg"); doSearch(); });

  // Restore & init voices
  function restore(){
    const savedRate = localStorage.getItem(STORAGE.lastRate);
    const savedPitch = localStorage.getItem(STORAGE.lastPitch);
    const savedVoice = localStorage.getItem(STORAGE.lastVoice);
    const savedHighlight = localStorage.getItem(STORAGE.highlight);
    const savedSetStart = localStorage.getItem(STORAGE.setStartMode);
    if (savedRate) rate.value = savedRate;
    if (savedPitch) pitch.value = savedPitch;
    if (savedHighlight) highlightToggle.checked = savedHighlight === "1";
    if (savedSetStart) setStartMode.checked = savedSetStart === "1";
    populateVoices();
    if (savedVoice) voiceSelect.value = savedVoice;

    const lastText = localStorage.getItem(STORAGE.lastText) || "";
    const lastLabel = localStorage.getItem(STORAGE.lastLabel) || "Restored";
    const lastMode = localStorage.getItem(STORAGE.lastMode) || "text";
    if (lastText) loadText(lastText, lastLabel, lastMode);
    else { setDocTitle("Reader", "text"); updateProgress(); }
  }

  if (typeof speechSynthesis !== "undefined"){
    populateVoices();
    speechSynthesis.onvoiceschanged = populateVoices;
  } else {
    setStatus(ttsStatus, "SpeechSynthesis not supported in this browser.", "warn");
  }
  restore();

  // Service worker registration
  if ("serviceWorker" in navigator) {
    window.addEventListener("load", () => {
      navigator.serviceWorker.register("./sw.js").catch(() => {});
    });
  }
</script>
</body>
</html>
