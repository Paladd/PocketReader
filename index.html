<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#0b0c10" />
  <title>Pocket Reader</title>

  <link rel="manifest" href="./manifest.webmanifest" />

  <style>
    :root{
      --bg:#0b0c10;
      --card:#12141b;
      --panel:#0f1220;
      --stroke:#22263a;
      --stroke2:#2b3150;
      --text:#e7e7e7;
      --muted:#aeb3c7;
      --brand:#2a5bd7;
      --danger:#b63b3b;
      color-scheme: dark;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    body{ margin:0; background:var(--bg); color:var(--text); }
    .app{ min-height:100vh; display:grid; grid-template-rows:auto auto 1fr; }

    .topbar{
      position:sticky; top:0; z-index:50;
      background:rgba(18,20,27,.9);
      backdrop-filter: blur(10px);
      border-bottom:1px solid var(--stroke);
      padding:12px 14px;
      display:flex; align-items:center; justify-content:space-between; gap:10px;
    }
    .brand{ display:flex; align-items:center; gap:10px; }
    .logo{
      width:34px; height:34px; border-radius:10px;
      background:linear-gradient(135deg, var(--brand), #8ab4ff);
      box-shadow: 0 10px 30px rgba(42,91,215,.25);
    }
    .brand h1{ margin:0; font-size:16px; letter-spacing:.2px; }
    .brand .sub{ margin:2px 0 0 0; font-size:12px; color:var(--muted); }

    .chipbar{
      padding:10px 12px;
      display:flex; gap:8px; flex-wrap:wrap;
      border-bottom:1px solid var(--stroke);
      background:rgba(15,18,32,.5);
    }
    .chip{
      border:1px solid var(--stroke2);
      background:rgba(18,20,27,.65);
      color:var(--text);
      padding:8px 12px;
      border-radius:999px;
      font-weight:800;
      cursor:pointer;
      user-select:none;
      font-size:13px;
    }
    .chip.active{ border-color:var(--brand); box-shadow: 0 0 0 3px rgba(42,91,215,.15); }

    .content{
      padding:12px;
      display:grid;
      grid-template-columns: 420px 1fr;
      gap:12px;
    }
    @media (max-width: 980px){ .content{ grid-template-columns: 1fr; } }

    .card{
      background:var(--card);
      border:1px solid var(--stroke);
      border-radius:16px;
      overflow:hidden;
      box-shadow: 0 10px 30px rgba(0,0,0,.25);
    }
    .card .hd{
      padding:12px;
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      border-bottom:1px solid var(--stroke);
      font-weight:900;
    }
    .card .bd{ padding:12px; }

    input, select, button, textarea{
      width:100%;
      box-sizing:border-box;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid var(--stroke2);
      background:var(--panel);
      color:var(--text);
      outline:none;
      font-size:14px;
    }
    textarea{ min-height:90px; resize:vertical; }
    button{ cursor:pointer; font-weight:900; }
    .primary{ background:var(--brand); border-color:var(--brand); }
    .ghost{ background:transparent; }
    .danger{ background:var(--danger); border-color:var(--danger); }

    .row{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    .row > *{ flex:1; }
    .muted{ color:var(--muted); font-size:12px; }
    .status{ margin-top:8px; font-size:12px; color:#9fe6b8; white-space:pre-wrap; }
    .warn{ color:#ffd27d; }
    .dangerText{ color:#ff9f9f; }

    #reader{
      white-space:pre-wrap;
      line-height:1.7;
      font-size:18px;
      padding:16px;
      background:var(--panel);
      border-radius:16px;
      min-height:280px;
      max-height:62vh;
      overflow:auto;
      border:1px solid var(--stroke);
    }
    @media (max-width:980px){ #reader{ max-height:52vh; } }
    .sent{ padding:.12em 0; border-radius:8px; cursor:pointer; }
    .sent:hover{ outline:1px solid rgba(174,179,199,.25); }
    .sent.active{ background: rgba(42,91,215,.22); outline:1px solid rgba(42,91,215,.45); }

    .progressWrap{ margin-top:10px; }
    .progressBar{
      width:100%; height:10px; border-radius:999px;
      background:var(--panel);
      border:1px solid var(--stroke2);
      overflow:hidden;
    }
    .progressFill{ height:100%; width:0%; background:var(--brand); }

    /* Floating player */
    .playerFab{
      position: fixed;
      right: 14px;
      bottom: 14px;
      z-index: 60;
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 10px;
    }
    .fabMain{
      width: auto;
      border-radius: 999px;
      padding: 12px 14px;
      border: 1px solid var(--stroke2);
      background: rgba(18,20,27,.92);
      backdrop-filter: blur(10px);
      display: flex;
      align-items: center;
      gap: 10px;
      box-shadow: 0 14px 40px rgba(0,0,0,.35);
    }
    .fabMain:active{ transform: scale(0.99); }
    .fabPct{ font-size: 12px; color: var(--muted); font-weight: 900; }
    .fabPanel{
      width: min(360px, calc(100vw - 28px));
      border-radius: 16px;
      border: 1px solid var(--stroke);
      background: rgba(18,20,27,.92);
      backdrop-filter: blur(10px);
      padding: 12px;
      box-shadow: 0 18px 60px rgba(0,0,0,.45);
      display: none;
    }
    .fabPanel.open{ display: block; }
    .hideFab .fabMain{ opacity: 0.15; }
    .hideFab .fabMain:hover{ opacity: 1; }

    .previewImg{
      width:100%;
      border-radius:16px;
      border:1px solid var(--stroke);
      background:var(--panel);
      max-height:240px;
      object-fit:contain;
    }

    .smallBtn{ width:auto; flex:0 0 auto; padding:10px 12px; }
    .tiny{ font-size:11px; color:var(--muted); }
  </style>

  <!-- DOCX -> text -->
  <script src="https://unpkg.com/mammoth/mammoth.browser.min.js"></script>
  <!-- PDF.js -->
  <script src="https://unpkg.com/pdfjs-dist@4.10.38/build/pdf.min.js"></script>
  <!-- OCR -->
  <script src="https://unpkg.com/tesseract.js@5.1.0/dist/tesseract.min.js"></script>
</head>

<body>
<div class="app">
  <div class="topbar">
    <div class="brand">
      <div class="logo" aria-hidden="true"></div>
      <div>
        <h1>Pocket Reader</h1>
        <div class="sub">DOCX + PDF + OCR + Read Aloud</div>
      </div>
    </div>
  </div>

  <div class="chipbar">
    <div class="chip active" data-tab="load">Load</div>
    <div class="chip" data-tab="ocr">OCR</div>
    <div class="chip" data-tab="tips">Tips</div>
  </div>

  <div class="content">
    <section class="card">
      <div class="hd"><span id="leftTitle">Load</span></div>
      <div class="bd">

        <!-- LOAD -->
        <div class="tab" id="tab-load">
          <div class="muted">Supports .txt, .md, .html, .docx, .pdf (text PDFs only)</div>
          <div style="height:10px;"></div>

          <input id="fileInput" type="file"
            accept=".txt,.text,.md,.html,.htm,.docx,.pdf,application/pdf,application/vnd.openxmlformats-officedocument.wordprocessingml.document" />
          <div id="fileStatus" class="status"></div>

          <div style="height:14px;"></div>
          <div class="muted">Or paste text:</div>
          <textarea id="pasteBox" placeholder="Paste text here..."></textarea>

          <div class="row" style="margin-top:8px;">
            <button id="usePaste" class="primary">Load pasted text</button>
            <button id="clearText">Clear</button>
          </div>
        </div>

        <!-- OCR -->
        <div class="tab" id="tab-ocr" style="display:none;">
          <div class="muted">
            For scanned PDFs: pick the PDF here, choose a page, render it, then OCR it.
          </div>
          <div style="height:10px;"></div>

          <div class="muted">Option A: OCR an image (screenshot/photo)</div>
          <input id="imgInput" type="file" accept="image/*,.png,.jpg,.jpeg,.webp" />
          <div style="height:10px;"></div>

          <div class="muted">Option B: OCR a scanned PDF page</div>
          <input id="pdfOcrInput" type="file" accept=".pdf,application/pdf" />

          <div style="height:10px;"></div>
          <div class="row">
            <label class="muted" style="flex:1;">
              PDF page
              <input id="pdfPage" type="number" min="1" value="1" />
            </label>
            <button id="renderPdfPage" class="ghost smallBtn">Render</button>
          </div>

          <div class="row" style="margin-top:8px;">
            <select id="ocrLang">
              <option value="eng" selected>English</option>
              <option value="spa">Spanish</option>
              <option value="fra">French</option>
              <option value="deu">German</option>
            </select>
            <button id="runOcr" class="primary">Run OCR</button>
          </div>

          <div style="height:10px;"></div>
          <canvas id="pdfCanvas" style="display:none;"></canvas>
          <img id="ocrPreview" class="previewImg" alt="OCR preview" style="display:none;" />

          <div id="ocrStatus" class="status"></div>

          <div class="row" style="margin-top:8px;">
            <button id="ocrToReader" class="ghost">Load OCR text into Reader</button>
            <button id="ocrSpeak" class="primary">Load + Speak</button>
          </div>

          <div class="tiny" style="margin-top:10px;">
            Tip: On iPhone, OCR works best if you “Render” the page first, then OCR.
            Trying to OCR huge multi-page PDFs all at once is where Safari usually dies.
          </div>
        </div>

        <!-- TIPS -->
        <div class="tab" id="tab-tips" style="display:none;">
          <div class="muted" style="line-height:1.6;">
            <b>Why OCR didn’t “see” your scanned PDF:</b><br/>
            OCR reads images. A scanned PDF is images inside a PDF container. So we must render a page first, then OCR.<br/><br/>
            <b>Best results:</b><br/>
            Use “Render” on the page, then “Run OCR”. If the page is skewed or blurry, OCR quality drops fast.
          </div>
        </div>

      </div>
    </section>

    <section class="card">
      <div class="hd">
        <span id="docLabel">Reader</span>
        <span class="muted" id="modeLabel">mode: text</span>
      </div>
      <div class="bd">
        <div class="muted">Tap a sentence to jump.</div>

        <div class="progressWrap">
          <div class="progressBar"><div id="progressFill" class="progressFill"></div></div>
          <div id="progressText" class="muted" style="margin-top:6px;">0%</div>
        </div>

        <div style="height:10px;"></div>
        <div id="reader">Load something, then tap ▶ to speak.</div>

        <div id="ttsStatus" class="status"></div>
      </div>
    </section>
  </div>

  <!-- Floating player -->
  <div class="playerFab">
    <button class="fabMain" id="fabToggle" aria-label="Toggle player">
      <span id="fabIcon">▶</span>
      <span id="fabPct" class="fabPct">0%</span>
    </button>

    <div class="fabPanel" id="fabPanel" aria-hidden="true">
      <div class="row" style="gap:8px; margin-bottom:10px;">
        <select id="voiceSelect" aria-label="Voice"></select>
      </div>

      <div class="row" style="gap:8px;">
        <button id="speak" class="primary" style="width:auto;">▶ Speak</button>
        <button id="pause" class="ghost" style="width:auto;">⏸</button>
        <button id="resume" class="ghost" style="width:auto;">⏵</button>
        <button id="stop" class="danger" style="width:auto;">■</button>
      </div>

      <div class="row" style="gap:12px; margin-top:10px; align-items:center;">
        <label class="muted" style="display:flex; gap:8px; align-items:center; flex:1;">
          <input id="highlightToggle" type="checkbox" style="width:auto;" checked />
          Highlight
        </label>
        <label class="muted" style="display:flex; gap:8px; align-items:center; flex:1;">
          <input id="setStartMode" type="checkbox" style="width:auto;" />
          Set Start Here
        </label>
      </div>

      <div style="height:10px;"></div>
      <div class="muted">Rate</div>
      <input id="rate" type="range" min="0.7" max="1.2" value="1.0" step="0.05" />

      <div style="height:10px;"></div>
      <div class="muted">Pitch</div>
      <input id="pitch" type="range" min="0.8" max="1.2" value="1.0" step="0.05" />
    </div>
  </div>
</div>

<script>
  // Tabs
  const chips = [...document.querySelectorAll(".chip")];
  const tabs = {
    load: document.getElementById("tab-load"),
    ocr: document.getElementById("tab-ocr"),
    tips: document.getElementById("tab-tips"),
  };
  const leftTitle = document.getElementById("leftTitle");
  function setTab(name){
    chips.forEach(c => c.classList.toggle("active", c.dataset.tab === name));
    Object.entries(tabs).forEach(([k,el]) => el.style.display = (k===name ? "block" : "none"));
    leftTitle.textContent = name.charAt(0).toUpperCase() + name.slice(1);
  }
  chips.forEach(c => c.addEventListener("click", () => setTab(c.dataset.tab)));

  // PDF worker
  if (window.pdfjsLib) {
    pdfjsLib.GlobalWorkerOptions.workerSrc =
      "https://unpkg.com/pdfjs-dist@4.10.38/build/pdf.worker.min.js";
  }

  // DOM
  const fileInput = document.getElementById("fileInput");
  const fileStatus = document.getElementById("fileStatus");
  const pasteBox = document.getElementById("pasteBox");
  const usePaste = document.getElementById("usePaste");
  const clearText = document.getElementById("clearText");

  const reader = document.getElementById("reader");
  const docLabel = document.getElementById("docLabel");
  const modeLabel = document.getElementById("modeLabel");

  const voiceSelect = document.getElementById("voiceSelect");
  const rate = document.getElementById("rate");
  const pitch = document.getElementById("pitch");
  const highlightToggle = document.getElementById("highlightToggle");
  const setStartMode = document.getElementById("setStartMode");

  const speakBtn = document.getElementById("speak");
  const pauseBtn = document.getElementById("pause");
  const resumeBtn = document.getElementById("resume");
  const stopBtn = document.getElementById("stop");
  const ttsStatus = document.getElementById("ttsStatus");

  const progressFill = document.getElementById("progressFill");
  const progressText = document.getElementById("progressText");

  const fabToggle = document.getElementById("fabToggle");
  const fabPanel = document.getElementById("fabPanel");
  const fabIcon = document.getElementById("fabIcon");
  const fabPct = document.getElementById("fabPct");

  // OCR DOM
  const imgInput = document.getElementById("imgInput");
  const pdfOcrInput = document.getElementById("pdfOcrInput");
  const pdfPage = document.getElementById("pdfPage");
  const renderPdfPageBtn = document.getElementById("renderPdfPage");
  const pdfCanvas = document.getElementById("pdfCanvas");
  const ocrLang = document.getElementById("ocrLang");
  const runOcr = document.getElementById("runOcr");
  const ocrPreview = document.getElementById("ocrPreview");
  const ocrStatus = document.getElementById("ocrStatus");
  const ocrToReader = document.getElementById("ocrToReader");
  const ocrSpeak = document.getElementById("ocrSpeak");

  let ocrText = "";
  let imageURL = "";
  let loadedPdfBytes = null;
  let pdfNumPages = 0;
  let renderedDataURL = ""; // what OCR will actually process

  function setStatus(el, msg, kind="ok"){
    el.textContent = msg || "";
    el.className = "status " + (kind==="warn" ? "warn" : (kind==="danger" ? "dangerText" : ""));
  }

  function splitIntoSentences(text){
    const t = (text || "").replace(/\r\n/g, "\n").trim();
    if (!t) return [];
    const parts = t.split(/(?<=[.!?])\s+(?=[A-Z0-9“"'\(\[])/g);
    return parts.map(s => s.trim()).filter(Boolean);
  }

  const state = {
    textRaw: "",
    sentences: [],
    sentenceEls: [],
    currentSentenceIndex: 0,
    voices: [],
    speaking: false,
    label: "Loaded",
    mode: "text"
  };

  function renderReaderWithSentences(sentences){
    reader.innerHTML = "";
    state.sentenceEls = [];
    if (!sentences.length) { reader.textContent = "No text loaded."; return; }
    const frag = document.createDocumentFragment();
    sentences.forEach((s, idx) => {
      const span = document.createElement("span");
      span.className = "sent";
      span.dataset.idx = String(idx);
      span.textContent = s + " ";
      state.sentenceEls[idx] = span;
      frag.appendChild(span);
    });
    reader.appendChild(frag);
  }

  function clearActiveHighlight(){
    for (const el of state.sentenceEls) if (el) el.classList.remove("active");
  }
  function setActiveHighlight(i){
    if (!highlightToggle.checked) return;
    clearActiveHighlight();
    const el = state.sentenceEls[i];
    if (!el) return;
    el.classList.add("active");
    try { el.scrollIntoView({ block:"center", behavior:"smooth" }); } catch(e){}
  }

  function updateProgress(){
    const total = state.sentences.length || 0;
    const idx = Math.max(0, Math.min(state.currentSentenceIndex, Math.max(0, total-1)));
    const pct = total ? Math.round((idx / total) * 100) : 0;
    progressFill.style.width = pct + "%";
    progressText.textContent = total ? `${pct}% (sentence ${idx+1} of ${total})` : "0%";
    if (fabPct) fabPct.textContent = total ? `${pct}%` : "0%";
  }

  function setDocTitle(label, mode){
    docLabel.textContent = label || "Reader";
    modeLabel.textContent = "mode: " + (mode || "text");
  }

  function stopSpeaking(){
    try { speechSynthesis.cancel(); } catch(e) {}
    state.speaking = false;
    setStatus(ttsStatus, "");
    clearActiveHighlight();
    if (fabIcon) fabIcon.textContent = "▶";
  }

  function getSelectedVoice(){
    const name = voiceSelect.value;
    return state.voices.find(v => v.name === name) || null;
  }

  function speakFrom(index){
    if (!state.textRaw.trim()) { setStatus(ttsStatus, "No text loaded.", "warn"); return; }
    stopSpeaking();
    state.speaking = true;
    state.currentSentenceIndex = Math.max(0, Math.min(index, state.sentences.length - 1));
    updateProgress();
    if (fabIcon) fabIcon.textContent = "⏸";
    speakNextSentence();
  }

  function speakNextSentence(){
    if (!state.speaking) return;
    if (state.currentSentenceIndex >= state.sentences.length){
      state.speaking = false;
      setStatus(ttsStatus, "Finished.", "ok");
      clearActiveHighlight();
      if (fabIcon) fabIcon.textContent = "▶";
      return;
    }
    const s = state.sentences[state.currentSentenceIndex];
    const voice = getSelectedVoice();

    setActiveHighlight(state.currentSentenceIndex);
    updateProgress();

    const u = new SpeechSynthesisUtterance(s);
    if (voice) u.voice = voice;
    u.rate = parseFloat(rate.value);
    u.pitch = parseFloat(pitch.value);

    u.onstart = () => setStatus(ttsStatus, `Speaking ${state.currentSentenceIndex+1}/${state.sentences.length} • ${state.label}`, "ok");
    u.onerror = () => {
      state.speaking = false;
      setStatus(ttsStatus, "Speech error. Try a different voice.", "warn");
      clearActiveHighlight();
      if (fabIcon) fabIcon.textContent = "▶";
    };
    u.onend = () => {
      state.currentSentenceIndex += 1;
      speakNextSentence();
    };

    speechSynthesis.speak(u);
  }

  function populateVoices(){
    const vs = speechSynthesis.getVoices();
    if (!vs || !vs.length) return;
    state.voices = vs;
    voiceSelect.innerHTML = "";
    const sorted = [...vs].sort((a,b) => {
      const aUS = (a.lang || "").toLowerCase().includes("en-us");
      const bUS = (b.lang || "").toLowerCase().includes("en-us");
      if (aUS !== bUS) return bUS - aUS;
      return (a.name || "").localeCompare(b.name || "");
    });
    for (const v of sorted){
      const opt = document.createElement("option");
      opt.value = v.name;
      opt.textContent = `${v.name} — ${v.lang}${v.default ? " (default)" : ""}`;
      voiceSelect.appendChild(opt);
    }
    // Pick first en-US if available
    const preferred = sorted.find(v => (v.lang || "").toLowerCase().includes("en-us"))?.name || sorted[0]?.name;
    if (preferred) voiceSelect.value = preferred;
  }

  function loadText(text, label, mode="text"){
    stopSpeaking();
    state.mode = mode;
    state.label = label || "Loaded";
    state.textRaw = text || "";
    state.sentences = splitIntoSentences(state.textRaw);
    state.currentSentenceIndex = 0;
    renderReaderWithSentences(state.sentences);
    setDocTitle(state.label, state.mode);
    setActiveHighlight(0);
    updateProgress();
    setStatus(fileStatus, state.textRaw.trim() ? `${label} (${state.textRaw.length.toLocaleString()} chars)` : "No text loaded.", state.textRaw.trim() ? "ok" : "warn");
  }

  // Floating player toggle + hide-on-scroll
  let panelOpen = false;
  fabToggle.addEventListener("click", () => {
    panelOpen = !panelOpen;
    fabPanel.classList.toggle("open", panelOpen);
    fabPanel.setAttribute("aria-hidden", panelOpen ? "false" : "true");
  });
  let scrollTimer = null;
  reader.addEventListener("scroll", () => {
    document.body.classList.add("hideFab");
    if (scrollTimer) clearTimeout(scrollTimer);
    scrollTimer = setTimeout(() => document.body.classList.remove("hideFab"), 420);
  });

  // Reader click jump
  reader.addEventListener("click", (e) => {
    const sent = e.target.closest(".sent");
    if (!sent) return;
    const idx = parseInt(sent.dataset.idx, 10);
    if (Number.isNaN(idx)) return;
    state.currentSentenceIndex = idx;
    setActiveHighlight(idx);
    updateProgress();
    if (!setStartMode.checked) speakFrom(idx);
    else setStatus(ttsStatus, "Start point set. Press Speak.", "ok");
  });

  // Controls
  speakBtn.addEventListener("click", () => speakFrom(state.currentSentenceIndex || 0));
  pauseBtn.addEventListener("click", () => { try { speechSynthesis.pause(); } catch(e){} if (fabIcon) fabIcon.textContent = "▶"; });
  resumeBtn.addEventListener("click", () => { try { speechSynthesis.resume(); } catch(e){} if (fabIcon) fabIcon.textContent = "⏸"; });
  stopBtn.addEventListener("click", stopSpeaking);

  // DOCX -> text
  async function docxToText(arrayBuffer){
    const result = await mammoth.extractRawText({ arrayBuffer });
    return (result && result.value ? result.value : "").replace(/\n{3,}/g, "\n\n").trim();
  }

  // PDF -> text (for text PDFs)
  async function pdfToText(arrayBuffer){
    if (!window.pdfjsLib) throw new Error("PDF engine not loaded");
    const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer });
    const pdf = await loadingTask.promise;
    let out = [];
    for (let p = 1; p <= pdf.numPages; p++){
      const page = await pdf.getPage(p);
      const tc = await page.getTextContent();
      const pageText = tc.items.map(it => it.str).join(" ");
      out.push(pageText);
    }
    return out.join("\n\n").replace(/\s{2,}/g, " ").trim();
  }

  // Load tab file input
  fileInput.addEventListener("change", async (e) => {
    const f = e.target.files && e.target.files[0];
    if (!f) return;
    const name = (f.name || "file").toLowerCase();
    setStatus(fileStatus, `Loading: ${f.name}…`, "ok");

    try{
      if (name.endsWith(".docx")){
        const text = await docxToText(await f.arrayBuffer());
        loadText(text, `Loaded DOCX: ${f.name}`, "text");
        return;
      }
      if (name.endsWith(".pdf") || f.type === "application/pdf"){
        const text = await pdfToText(await f.arrayBuffer());
        if (!text || text.length < 10){
          setStatus(fileStatus, "This PDF looks scanned (image-only). Use OCR tab: upload the PDF, Render a page, then Run OCR.", "warn");
          loadText("", "PDF (no extractable text)", "text");
        } else {
          loadText(text, `Loaded PDF: ${f.name}`, "text");
        }
        return;
      }
      const raw = await f.text();
      loadText(raw, `Loaded file: ${f.name}`, "text");
    } catch(err){
      console.error(err);
      setStatus(fileStatus, "Could not read that file. If it’s scanned, use the OCR tab.", "warn");
    } finally {
      fileInput.value = "";
    }
  });

  usePaste.addEventListener("click", () => loadText(pasteBox.value || "", "Loaded pasted text", "text"));
  clearText.addEventListener("click", () => { pasteBox.value = ""; loadText("", "Cleared", "text"); });

  // OCR: image upload
  imgInput.addEventListener("change", async (e) => {
    const f = e.target.files && e.target.files[0];
    if (!f) return;
    if (imageURL) URL.revokeObjectURL(imageURL);
    imageURL = URL.createObjectURL(f);
    renderedDataURL = ""; // if you upload an image, OCR should use the image URL
    ocrPreview.src = imageURL;
    ocrPreview.style.display = "block";
    pdfCanvas.style.display = "none";
    ocrText = "";
    setStatus(ocrStatus, "Image loaded. Tap Run OCR.", "ok");
  });

  // OCR: PDF upload (scanned PDF)
  pdfOcrInput.addEventListener("change", async (e) => {
    const f = e.target.files && e.target.files[0];
    if (!f) return;

    loadedPdfBytes = await f.arrayBuffer();
    setStatus(ocrStatus, "PDF loaded. Tap Render to preview a page, then Run OCR.", "ok");

    // Get page count
    try{
      const pdf = await pdfjsLib.getDocument({ data: loadedPdfBytes }).promise;
      pdfNumPages = pdf.numPages;
      if (pdfPage) {
        pdfPage.max = String(pdfNumPages);
        if (parseInt(pdfPage.value,10) > pdfNumPages) pdfPage.value = "1";
      }
      setStatus(ocrStatus, `PDF loaded (${pdfNumPages} pages). Set page number and tap Render.`, "ok");
    } catch(err){
      console.error(err);
      setStatus(ocrStatus, "Could not open that PDF.", "warn");
      loadedPdfBytes = null;
      pdfNumPages = 0;
    }
  });

  // Render selected PDF page to canvas, then to image preview
  renderPdfPageBtn.addEventListener("click", async () => {
    if (!loadedPdfBytes){
      setStatus(ocrStatus, "Upload a PDF first.", "warn");
      return;
    }
    const pageNum = Math.max(1, parseInt(pdfPage.value || "1", 10));
    setStatus(ocrStatus, `Rendering page ${pageNum}…`, "ok");

    try{
      const pdf = await pdfjsLib.getDocument({ data: loadedPdfBytes }).promise;
      const p = Math.min(pageNum, pdf.numPages);
      const page = await pdf.getPage(p);

      // Mobile-friendly render scale
      const viewport = page.getViewport({ scale: 2.0 });
      const ctx = pdfCanvas.getContext("2d", { willReadFrequently: true });
      pdfCanvas.width = Math.floor(viewport.width);
      pdfCanvas.height = Math.floor(viewport.height);

      await page.render({ canvasContext: ctx, viewport }).promise;

      // Turn canvas into a data URL for OCR
      renderedDataURL = pdfCanvas.toDataURL("image/png");
      ocrPreview.src = renderedDataURL;
      ocrPreview.style.display = "block";
      pdfCanvas.style.display = "none";

      setStatus(ocrStatus, `Rendered page ${p}. Now tap Run OCR.`, "ok");
    } catch(err){
      console.error(err);
      setStatus(ocrStatus, "Render failed. Try a different page or a smaller PDF.", "warn");
    }
  });

  // Run OCR on either uploaded image or rendered PDF page
  runOcr.addEventListener("click", async () => {
    const source = renderedDataURL || imageURL;
    if (!source){
      setStatus(ocrStatus, "Upload an image OR upload a PDF and render a page first.", "warn");
      return;
    }
    if (!window.Tesseract){
      setStatus(ocrStatus, "OCR engine not loaded. This is usually a cache issue. Refresh with ?v=6.", "warn");
      return;
    }

    setStatus(ocrStatus, "OCR running… (on iPhone, give it a moment)", "ok");

    try{
      const langCode = ocrLang.value;
      const { data } = await Tesseract.recognize(source, langCode, {
        logger: m => {
          if (m.status && typeof m.progress === "number") {
            const pct = Math.round(m.progress * 100);
            setStatus(ocrStatus, `OCR: ${m.status} • ${pct}%`, "ok");
          }
        }
      });

      ocrText = (data && data.text ? data.text : "").trim();
      if (!ocrText) setStatus(ocrStatus, "OCR finished but found little/no text. Try a clearer page.", "warn");
      else setStatus(ocrStatus, `OCR complete. ${ocrText.length.toLocaleString()} characters found.`, "ok");
    } catch (err){
      console.error(err);
      setStatus(ocrStatus, "OCR failed. Try rendering at a lower scale or use a screenshot.", "warn");
    }
  });

  ocrToReader.addEventListener("click", () => {
    if (!ocrText) { setStatus(ocrStatus, "Run OCR first.", "warn"); return; }
    loadText(ocrText, "OCR text", "text");
  });

  ocrSpeak.addEventListener("click", () => {
    if (!ocrText) { setStatus(ocrStatus, "Run OCR first.", "warn"); return; }
    loadText(ocrText, "OCR text", "text");
    speakFrom(0);
  });

  // Voices init
  if (typeof speechSynthesis !== "undefined"){
    populateVoices();
    speechSynthesis.onvoiceschanged = populateVoices;
  } else {
    setStatus(ttsStatus, "SpeechSynthesis not supported in this browser.", "warn");
  }

  // Service worker registration
  if ("serviceWorker" in navigator) {
    window.addEventListener("load", () => {
      navigator.serviceWorker.register("./sw.js").catch(() => {});
    });
  }
</script>
</body>
</html>
