<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#0b0c10" />
  <title>Pocket Reader</title>
  <link rel="manifest" href="./manifest.webmanifest" />

  <style>
    :root{
      --bg:#0b0c10; --card:#12141b; --panel:#0f1220;
      --stroke:#22263a; --stroke2:#2b3150;
      --text:#e7e7e7; --muted:#aeb3c7; --brand:#2a5bd7; --danger:#b63b3b;
      color-scheme: dark;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    body{ margin:0; background:var(--bg); color:var(--text); }
    .app{ min-height:100vh; display:grid; grid-template-rows:auto auto 1fr; }

    .topbar{
      position:sticky; top:0; z-index:50;
      background:rgba(18,20,27,.9); backdrop-filter: blur(10px);
      border-bottom:1px solid var(--stroke);
      padding:12px 14px; display:flex; align-items:center; gap:10px;
    }
    .logo{ width:34px; height:34px; border-radius:10px;
      background:linear-gradient(135deg, var(--brand), #8ab4ff);
      box-shadow: 0 10px 30px rgba(42,91,215,.25);
    }
    h1{ margin:0; font-size:16px; }
    .sub{ margin:2px 0 0 0; font-size:12px; color:var(--muted); }

    .chipbar{
      padding:10px 12px; display:flex; gap:8px; flex-wrap:wrap;
      border-bottom:1px solid var(--stroke);
      background:rgba(15,18,32,.5);
    }
    .chip{
      border:1px solid var(--stroke2);
      background:rgba(18,20,27,.65);
      color:var(--text);
      padding:8px 12px;
      border-radius:999px;
      font-weight:800;
      cursor:pointer;
      user-select:none;
      font-size:13px;
    }
    .chip.active{ border-color:var(--brand); box-shadow: 0 0 0 3px rgba(42,91,215,.15); }

    .content{
      padding:12px;
      display:grid;
      grid-template-columns: 420px 1fr;
      gap:12px;
    }
    @media (max-width: 980px){ .content{ grid-template-columns: 1fr; } }

    .card{
      background:var(--card);
      border:1px solid var(--stroke);
      border-radius:16px;
      overflow:hidden;
      box-shadow: 0 10px 30px rgba(0,0,0,.25);
    }
    .hd{
      padding:12px;
      display:flex; align-items:center; justify-content:space-between;
      border-bottom:1px solid var(--stroke);
      font-weight:900;
    }
    .bd{ padding:12px; }

    input, select, button, textarea{
      width:100%;
      box-sizing:border-box;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid var(--stroke2);
      background:var(--panel);
      color:var(--text);
      outline:none;
      font-size:14px;
    }
    textarea{ min-height:90px; resize:vertical; }
    button{ cursor:pointer; font-weight:900; }
    .primary{ background:var(--brand); border-color:var(--brand); }
    .ghost{ background:transparent; }
    .row{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    .row > *{ flex:1; }

    .muted{ color:var(--muted); font-size:12px; }
    .status{ margin-top:8px; font-size:12px; color:#9fe6b8; white-space:pre-wrap; }
    .warn{ color:#ffd27d; }
    .dangerText{ color:#ff9f9f; }

    #reader{
      white-space:pre-wrap;
      line-height:1.7;
      font-size:18px;
      padding:16px;
      background:var(--panel);
      border-radius:16px;
      min-height:280px;
      max-height:62vh;
      overflow:auto;
      border:1px solid var(--stroke);
    }
    .sent{ padding:.12em 0; border-radius:8px; cursor:pointer; }
    .sent.active{ background: rgba(42,91,215,.22); outline:1px solid rgba(42,91,215,.45); }

    .playerFab{
      position: fixed; right: 14px; bottom: 14px; z-index: 60;
      display: flex; flex-direction: column; align-items: flex-end; gap: 10px;
    }
    .fabMain{
      border-radius: 999px;
      padding: 12px 14px;
      border: 1px solid var(--stroke2);
      background: rgba(18,20,27,.92);
      backdrop-filter: blur(10px);
      display: flex; align-items: center; gap: 10px;
      box-shadow: 0 14px 40px rgba(0,0,0,.35);
      width:auto;
    }
    .fabPanel{
      width: min(360px, calc(100vw - 28px));
      border-radius: 16px;
      border: 1px solid var(--stroke);
      background: rgba(18,20,27,.92);
      backdrop-filter: blur(10px);
      padding: 12px;
      box-shadow: 0 18px 60px rgba(0,0,0,.45);
      display: none;
    }
    .fabPanel.open{ display: block; }
  </style>

  <!-- DOCX parser -->
  <script src="https://unpkg.com/mammoth/mammoth.browser.min.js"></script>

  <!-- PDF.js core -->
  <script src="https://unpkg.com/pdfjs-dist@4.10.38/build/pdf.min.js" defer></script>
</head>

<body>
<div class="app">
  <div class="topbar">
    <div class="logo"></div>
    <div>
      <h1>Pocket Reader</h1>
      <div class="sub">DOCX + PDF text + Gutenberg + clean errors</div>
    </div>
  </div>

  <div class="chipbar">
    <div class="chip active" data-tab="load">Load</div>
    <div class="chip" data-tab="gutenberg">Gutenberg</div>
  </div>

  <div class="content">
    <section class="card">
      <div class="hd"><span id="leftTitle">Load</span></div>
      <div class="bd">

        <div class="tab" id="tab-load">
          <div class="muted">Use Any File on iPhone. DOCX must be true .docx (not old .doc).</div>
          <div style="height:10px;"></div>

          <div class="muted">Any File (recommended)</div>
          <input id="anyFileInput" type="file" accept="*/*" />

          <div style="height:10px;"></div>
          <div class="muted">Filtered picker (optional)</div>
          <input id="fileInput" type="file"
            accept=".txt,.text,.md,.html,.htm,.docx,.pdf,application/pdf,application/vnd.openxmlformats-officedocument.wordprocessingml.document" />

          <div id="fileStatus" class="status"></div>

          <div style="height:14px;"></div>
          <div class="muted">Or paste text:</div>
          <textarea id="pasteBox" placeholder="Paste text here..."></textarea>
          <div class="row" style="margin-top:8px;">
            <button id="usePaste" class="primary">Load pasted text</button>
            <button id="clearText" class="ghost">Clear</button>
          </div>
        </div>

        <div class="tab" id="tab-gutenberg" style="display:none;">
          <div class="muted">Search Project Gutenberg (via Gutendex). Load into reader.</div>
          <div style="height:10px;"></div>
          <div class="row">
            <input id="gbQuery" type="text" placeholder="Search title or author" />
            <button id="gbSearch" class="primary" style="width:auto;">Search</button>
          </div>
          <div id="gbStatus" class="status"></div>
          <div id="gbResults" class="status" style="white-space:normal;"></div>
        </div>

      </div>
    </section>

    <section class="card">
      <div class="hd">
        <span id="docLabel">Reader</span>
        <span class="muted" id="modeLabel">mode: text</span>
      </div>
      <div class="bd">
        <div id="reader">Load something, then tap ▶ to speak.</div>
        <div id="ttsStatus" class="status"></div>
      </div>
    </section>
  </div>

  <div class="playerFab">
    <button class="fabMain" id="fabToggle" aria-label="Toggle player">
      <span id="fabIcon">▶</span>
      <span class="muted" id="fabVoice">Voice</span>
    </button>

    <div class="fabPanel" id="fabPanel">
      <select id="voiceSelect"></select>
      <div class="row" style="margin-top:10px;">
        <button id="speak" class="primary" style="width:auto;">▶ Speak</button>
        <button id="pause" class="ghost" style="width:auto;">⏸</button>
        <button id="resume" class="ghost" style="width:auto;">⏵</button>
        <button id="stop" class="ghost" style="width:auto;">■</button>
      </div>
      <div style="height:10px;"></div>
      <div class="muted">Rate</div>
      <input id="rate" type="range" min="0.7" max="1.2" value="1.0" step="0.05" />
      <div style="height:10px;"></div>
      <div class="muted">Pitch</div>
      <input id="pitch" type="range" min="0.8" max="1.2" value="1.0" step="0.05" />
    </div>
  </div>
</div>

<script>
  // ---- PDF.js worker MUST be set inside script (here) ----
  if (typeof pdfjsLib === "undefined") {
  console.error("PDF.js failed to load");
}

  if (typeof pdfjsLib !== "undefined") {
  pdfjsLib.GlobalWorkerOptions.workerSrc =
    "https://unpkg.com/pdfjs-dist@4.10.38/build/pdf.worker.min.js";
}
if (typeof pdfjsLib === "undefined") {
  setStatus(fileStatus, "PDF engine not loaded. Reload the app.", "danger");
  return;
}

  // Tabs
  const chips = [...document.querySelectorAll(".chip")];
  const tabs = {
    load: document.getElementById("tab-load"),
    gutenberg: document.getElementById("tab-gutenberg"),
  };
  const leftTitle = document.getElementById("leftTitle");
  function setTab(name){
    chips.forEach(c => c.classList.toggle("active", c.dataset.tab === name));
    Object.entries(tabs).forEach(([k,el]) => el.style.display = (k===name ? "block" : "none"));
    leftTitle.textContent = name.charAt(0).toUpperCase() + name.slice(1);
  }
  chips.forEach(c => c.addEventListener("click", () => setTab(c.dataset.tab)));

  // DOM
  const fileInput = document.getElementById("fileInput");
  const anyFileInput = document.getElementById("anyFileInput");
  const fileStatus = document.getElementById("fileStatus");

  const reader = document.getElementById("reader");
  const docLabel = document.getElementById("docLabel");
  const modeLabel = document.getElementById("modeLabel");
  const ttsStatus = document.getElementById("ttsStatus");

  const voiceSelect = document.getElementById("voiceSelect");
  const rate = document.getElementById("rate");
  const pitch = document.getElementById("pitch");
  const fabToggle = document.getElementById("fabToggle");
  const fabPanel = document.getElementById("fabPanel");
  const fabVoice = document.getElementById("fabVoice");
  const fabIcon = document.getElementById("fabIcon");

  function setStatus(el, msg, kind="ok"){
    el.textContent = msg || "";
    el.className = "status " + (kind==="warn" ? "warn" : (kind==="danger" ? "dangerText" : ""));
  }

  // Reader state (simple)
  const state = { textRaw:"", voices:[] };

  function loadText(text, label){
    state.textRaw = (text || "").trim();
    docLabel.textContent = label || "Reader";
    modeLabel.textContent = "mode: text";
    reader.textContent = state.textRaw || "No text loaded.";
  }

  // DOCX
  async function docxToText(arrayBuffer){
    const result = await mammoth.extractRawText({ arrayBuffer });
    return (result && result.value ? result.value : "").replace(/\n{3,}/g, "\n\n").trim();
  }

  // PDF (text extraction)
  async function pdfToText(arrayBuffer){
    const bytes = new Uint8Array(arrayBuffer);

    const loadingTask = pdfjsLib.getDocument({
      data: bytes,
      disableAutoFetch: true,
      disableStream: true,
      disableRange: true,
      stopAtErrors: false,
      verbosity: 0
    });

    loadingTask.onPassword = (updatePassword) => {
      const pw = prompt("This PDF is password-protected. Enter password:");
      if (pw) updatePassword(pw);
    };

    const pdf = await loadingTask.promise;

    let out = [];
    for (let p = 1; p <= pdf.numPages; p++){
      const page = await pdf.getPage(p);
      const tc = await page.getTextContent();
      const pageText = tc.items.map(it => it.str).join(" ");
      out.push(pageText);
    }
    return out.join("\n\n").replace(/\s{2,}/g, " ").trim();
  }

  async function handleFile(f){
    if (!f) return;

    setStatus(fileStatus,
      `Picked:\nName: ${f.name || "(no name)"}\nType: ${f.type || "(blank)"}\nSize: ${(f.size/1024).toFixed(0)} KB`,
      "ok"
    );

    const lower = (f.name || "").toLowerCase();

    try{
      // DOCX
      if (lower.endsWith(".docx") || (f.type||"").includes("wordprocessingml")){
        const text = await docxToText(await f.arrayBuffer());
        loadText(text, `DOCX: ${f.name}`);
        setStatus(fileStatus, "Loaded DOCX successfully.", "ok");
        return;
      }

      // PDF
      if (lower.endsWith(".pdf") || (f.type||"").includes("pdf")){
        const text = await pdfToText(await f.arrayBuffer());
        if (!text || text.length < 20){
          setStatus(fileStatus, "PDF opened, but it has no extractable text (likely scanned). OCR is next (not included in this build).", "warn");
          loadText("", `PDF (no text): ${f.name}`);
        } else {
          loadText(text, `PDF: ${f.name}`);
          setStatus(fileStatus, "Loaded PDF text successfully.", "ok");
        }
        return;
      }

      // Text fallback
      const raw = await f.text();
      loadText(raw, `File: ${f.name}`);
      setStatus(fileStatus, "Loaded as text.", "ok");
    } catch(err){
      console.error(err);
      setStatus(fileStatus, `Open failed:\n${err?.message || String(err)}`, "danger");
    }
  }

  fileInput.addEventListener("change", e => handleFile(e.target.files && e.target.files[0]));
  anyFileInput.addEventListener("change", e => handleFile(e.target.files && e.target.files[0]));

  // Paste
  document.getElementById("usePaste").addEventListener("click", () => {
    loadText(document.getElementById("pasteBox").value || "", "Pasted text");
  });
  document.getElementById("clearText").addEventListener("click", () => {
    document.getElementById("pasteBox").value = "";
    loadText("", "Cleared");
  });

  // Gutenberg
  const gbQuery = document.getElementById("gbQuery");
  const gbSearch = document.getElementById("gbSearch");
  const gbStatus = document.getElementById("gbStatus");
  const gbResults = document.getElementById("gbResults");

  function esc(s){ return (s||"").replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

  async function gutenbergSearch(q){
    gbResults.innerHTML = "";
    gbStatus.textContent = "Searching…";
    const url = `https://gutendex.com/books/?search=${encodeURIComponent(q)}`;
    const r = await fetch(url);
    if (!r.ok) throw new Error("Search failed");
    const data = await r.json();
    gbStatus.textContent = `Found ${data.results.length} results (showing up to 10).`;

    const top = data.results.slice(0,10);
    gbResults.innerHTML = top.map(b => {
      const title = esc(b.title);
      const author = esc((b.authors && b.authors[0] && b.authors[0].name) ? b.authors[0].name : "Unknown");
      const txt = b.formats?.["text/plain; charset=utf-8"] || b.formats?.["text/plain"] || "";
      const html = b.formats?.["text/html; charset=utf-8"] || b.formats?.["text/html"] || "";
      const best = txt || html;
      const btn = best ? `<button data-url="${esc(best)}" class="primary" style="margin-top:6px;">Load</button>` : `<div class="muted">No text format available.</div>`;
      return `
        <div style="border:1px solid #2b3150;border-radius:12px;padding:10px;margin-top:10px;background:#0f1220;">
          <div style="font-weight:900;">${title}</div>
          <div class="muted" style="font-size:11px;">${author}</div>
          ${btn}
        </div>
      `;
    }).join("");
  }

  gbSearch.addEventListener("click", async () => {
    const q = (gbQuery.value || "").trim();
    if (!q) return;
    try{ await gutenbergSearch(q); }
    catch(e){ gbStatus.textContent = "Gutenberg search failed. Check your connection."; }
  });

  gbResults.addEventListener("click", async (e) => {
    const btn = e.target.closest("button[data-url]");
    if (!btn) return;
    const url = btn.getAttribute("data-url");
    gbStatus.textContent = "Downloading…";
    try{
      const r = await fetch(url);
      const text = await r.text();
      loadText(text, "Gutenberg book");
      gbStatus.textContent = "Loaded into Reader.";
      setTab("load");
    } catch(e){
      gbStatus.textContent = "Could not download that book format.";
    }
  });

  // TTS UI
  let panelOpen = false;
  fabToggle.addEventListener("click", () => {
    panelOpen = !panelOpen;
    fabPanel.classList.toggle("open", panelOpen);
  });

  function populateVoices(){
    const vs = speechSynthesis.getVoices();
    if (!vs || !vs.length) return;
    state.voices = vs;
    voiceSelect.innerHTML = "";
    const sorted = [...vs].sort((a,b) => {
      const aUS = (a.lang || "").toLowerCase().includes("en-us");
      const bUS = (b.lang || "").toLowerCase().includes("en-us");
      if (aUS !== bUS) return bUS - aUS;
      return (a.name || "").localeCompare(b.name || "");
    });
    sorted.forEach(v => {
      const opt = document.createElement("option");
      opt.value = v.name;
      opt.textContent = `${v.name} — ${v.lang}`;
      voiceSelect.appendChild(opt);
    });
    const preferred = sorted.find(v => (v.lang||"").toLowerCase().includes("en-us"))?.name || sorted[0]?.name;
    if (preferred) voiceSelect.value = preferred;
    fabVoice.textContent = "Voice ready";
  }

  function stopSpeak(){ try{ speechSynthesis.cancel(); } catch(e){} fabIcon.textContent="▶"; }

  function speakAll(){
    if (!state.textRaw.trim()){
      setStatus(ttsStatus, "No text loaded.", "warn");
      return;
    }
    stopSpeak();
    fabIcon.textContent="⏸";
    const v = state.voices.find(x => x.name === voiceSelect.value) || null;

    const u = new SpeechSynthesisUtterance(state.textRaw);
    if (v) u.voice = v;
    u.rate = parseFloat(rate.value);
    u.pitch = parseFloat(pitch.value);
    u.onend = () => { fabIcon.textContent="▶"; };
    u.onerror = () => { setStatus(ttsStatus, "Speech error. Try another voice.", "warn"); fabIcon.textContent="▶"; };
    speechSynthesis.speak(u);
  }

  document.getElementById("speak").addEventListener("click", speakAll);
  document.getElementById("pause").addEventListener("click", () => { try{ speechSynthesis.pause(); } catch(e){} fabIcon.textContent="▶"; });
  document.getElementById("resume").addEventListener("click", () => { try{ speechSynthesis.resume(); } catch(e){} fabIcon.textContent="⏸"; });
  document.getElementById("stop").addEventListener("click", stopSpeak);

  if (typeof speechSynthesis !== "undefined"){
    populateVoices();
    speechSynthesis.onvoiceschanged = populateVoices;
  }
</script>
</body>
</html>
