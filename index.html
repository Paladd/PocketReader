<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#0b0c10" />
  <title>Pocket Reader</title>

  <link rel="manifest" href="./manifest.webmanifest" />

  <style>
    :root{
      --bg:#0b0c10;
      --card:#12141b;
      --panel:#0f1220;
      --stroke:#22263a;
      --stroke2:#2b3150;
      --text:#e7e7e7;
      --muted:#aeb3c7;
      --brand:#2a5bd7;
      --danger:#b63b3b;
      color-scheme: dark;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    body{ margin:0; background:var(--bg); color:var(--text); }
    .app{ min-height:100vh; display:grid; grid-template-rows:auto auto 1fr; }

    .topbar{
      position:sticky; top:0; z-index:50;
      background:rgba(18,20,27,.9);
      backdrop-filter: blur(10px);
      border-bottom:1px solid var(--stroke);
      padding:12px 14px;
      display:flex; align-items:center; justify-content:space-between; gap:10px;
    }
    .brand{ display:flex; align-items:center; gap:10px; }
    .logo{
      width:34px; height:34px; border-radius:10px;
      background:linear-gradient(135deg, var(--brand), #8ab4ff);
      box-shadow: 0 10px 30px rgba(42,91,215,.25);
    }
    .brand h1{ margin:0; font-size:16px; letter-spacing:.2px; }
    .brand .sub{ margin:2px 0 0 0; font-size:12px; color:var(--muted); }

    .chipbar{
      padding:10px 12px;
      display:flex; gap:8px; flex-wrap:wrap;
      border-bottom:1px solid var(--stroke);
      background:rgba(15,18,32,.5);
    }
    .chip{
      border:1px solid var(--stroke2);
      background:rgba(18,20,27,.65);
      color:var(--text);
      padding:8px 12px;
      border-radius:999px;
      font-weight:750;
      cursor:pointer;
      user-select:none;
      font-size:13px;
    }
    .chip.active{ border-color:var(--brand); box-shadow: 0 0 0 3px rgba(42,91,215,.15); }

    .content{
      padding:12px;
      display:grid;
      grid-template-columns: 420px 1fr;
      gap:12px;
    }
    @media (max-width: 980px){ .content{ grid-template-columns: 1fr; } }

    .card{
      background:var(--card);
      border:1px solid var(--stroke);
      border-radius:16px;
      overflow:hidden;
      box-shadow: 0 10px 30px rgba(0,0,0,.25);
    }
    .card .hd{
      padding:12px;
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      border-bottom:1px solid var(--stroke);
      font-weight:800;
    }
    .card .bd{ padding:12px; }

    input, select, button, textarea{
      width:100%;
      box-sizing:border-box;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid var(--stroke2);
      background:var(--panel);
      color:var(--text);
      outline:none;
      font-size:14px;
    }
    textarea{ min-height:90px; resize:vertical; }
    button{ cursor:pointer; font-weight:800; }
    .primary{ background:var(--brand); border-color:var(--brand); }
    .ghost{ background:transparent; }
    .danger{ background:var(--danger); border-color:var(--danger); }

    .row{ display:flex; gap:8px; flex-wrap:wrap; }
    .row > *{ flex:1; }
    .muted{ color:var(--muted); font-size:12px; }
    .status{ margin-top:8px; font-size:12px; color:#9fe6b8; }
    .warn{ color:#ffd27d; }
    .dangerText{ color:#ff9f9f; }

    /* Reader */
    #reader{
      white-space:pre-wrap;
      line-height:1.7;
      font-size:18px;
      padding:16px;
      background:var(--panel);
      border-radius:16px;
      min-height:280px;
      max-height:62vh;
      overflow:auto;
      border:1px solid var(--stroke);
    }
    @media (max-width:980px){ #reader{ max-height:52vh; } }
    .sent{ padding:.12em 0; border-radius:8px; cursor:pointer; }
    .sent:hover{ outline:1px solid rgba(174,179,199,.25); }
    .sent.active{ background: rgba(42,91,215,.22); outline:1px solid rgba(42,91,215,.45); }

    .progressWrap{ margin-top:10px; }
    .progressBar{
      width:100%; height:10px; border-radius:999px;
      background:var(--panel);
      border:1px solid var(--stroke2);
      overflow:hidden;
    }
    .progressFill{ height:100%; width:0%; background:var(--brand); }

    /* Scrubber overlay */
    #scrubOverlay{
      position:fixed; inset:0; display:none; z-index:9999;
      background: rgba(0,0,0,.55);
      align-items:center; justify-content:center; padding:16px;
    }
    #scrubCard{
      width:min(520px, 92vw);
      background:var(--card);
      border:1px solid var(--stroke);
      border-radius:16px;
      padding:14px;
    }
    #scrubPreview{
      margin-top:10px;
      padding:10px;
      border:1px solid var(--stroke);
      border-radius:14px;
      background:var(--panel);
      font-size:13px;
      color:var(--muted);
      max-height:140px;
      overflow:auto;
      white-space:pre-wrap;
    }

    /* EPUB */
    #epubHidden{ position:absolute; left:-99999px; top:-99999px; width:900px; height:700px; }
    .toc{ margin-top:10px; border:1px solid var(--stroke); border-radius:16px; background:var(--panel); max-height:240px; overflow:auto; padding:8px; }
    .toc button{
      width:100%; text-align:left; background:transparent; border:1px solid transparent;
      padding:8px 10px; border-radius:12px; margin:2px 0; font-weight:800;
    }
    .toc button:hover{ border-color:var(--stroke2); }
    .toc button.active{ border-color:var(--brand); }

    /* Gutenberg */
    #results{ display:flex; flex-direction:column; gap:10px; margin-top:10px; }
    .result{ padding:10px; border:1px solid var(--stroke); border-radius:16px; background:var(--panel); }
    .result .title{ font-weight:900; margin-bottom:4px; }
    .result .meta{ font-size:12px; color:var(--muted); margin-bottom:8px; }
    .pills{ display:flex; gap:8px; flex-wrap:wrap; }
    .pill, a.pill{
      display:inline-block; border:1px solid var(--stroke2); background:rgba(18,20,27,.65);
      padding:6px 10px; border-radius:999px; font-size:12px; cursor:pointer; user-select:none;
      color:var(--text); text-decoration:none;
    }

    /* Floating player */
    .playerFab{
      position: fixed;
      right: 14px;
      bottom: 14px;
      z-index: 60;
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 10px;
    }
    .fabMain{
      width: auto;
      border-radius: 999px;
      padding: 12px 14px;
      border: 1px solid var(--stroke2);
      background: rgba(18,20,27,.92);
      backdrop-filter: blur(10px);
      display: flex;
      align-items: center;
      gap: 10px;
      box-shadow: 0 14px 40px rgba(0,0,0,.35);
    }
    .fabMain:active{ transform: scale(0.99); }
    .fabPct{ font-size: 12px; color: var(--muted); font-weight: 900; }
    .fabPanel{
      width: min(360px, calc(100vw - 28px));
      border-radius: 16px;
      border: 1px solid var(--stroke);
      background: rgba(18,20,27,.92);
      backdrop-filter: blur(10px);
      padding: 12px;
      box-shadow: 0 18px 60px rgba(0,0,0,.45);
      display: none;
    }
    .fabPanel.open{ display: block; }
    .hideFab .fabMain{ opacity: 0.15; }
    .hideFab .fabMain:hover{ opacity: 1; }
  </style>

  <!-- EPUB.js -->
  <script src="https://unpkg.com/epubjs/dist/epub.min.js"></script>

  <!-- DOCX -> text (Mammoth) -->
  <script src="https://unpkg.com/mammoth/mammoth.browser.min.js"></script>

  <!-- PDF.js -->
  <script src="https://unpkg.com/pdfjs-dist@4.10.38/build/pdf.min.js"></script>
</head>

<body>
<div class="app">
  <div class="topbar">
    <div class="brand">
      <div class="logo" aria-hidden="true"></div>
      <div>
        <h1>Pocket Reader</h1>
        <div class="sub">DOCX + PDF + EPUB + Gutenberg + Read Aloud</div>
      </div>
    </div>
    <button id="installBtn" class="ghost" style="width:auto; display:none;">Install</button>
  </div>

  <div class="chipbar">
    <div class="chip active" data-tab="load">Load</div>
    <div class="chip" data-tab="gutenberg">Gutenberg</div>
    <div class="chip" data-tab="epub">EPUB</div>
    <div class="chip" data-tab="tips">Tips</div>
  </div>

  <div class="content">
    <section class="card">
      <div class="hd"><span id="leftTitle">Load</span></div>
      <div class="bd">

        <div class="tab" id="tab-load">
          <div class="muted">Supports .txt, .md, .html, .epub, .docx, .pdf</div>
          <div style="height:10px;"></div>

          <input id="fileInput" type="file"
            accept=".txt,.text,.md,.html,.htm,.epub,.docx,.pdf,application/pdf,application/vnd.openxmlformats-officedocument.wordprocessingml.document,application/epub+zip" />
          <div id="fileStatus" class="status"></div>

          <div style="height:14px;"></div>
          <div class="muted">Or paste text:</div>
          <textarea id="pasteBox" placeholder="Paste text here..."></textarea>

          <div class="row" style="margin-top:8px;">
            <button id="usePaste" class="primary">Load pasted text</button>
            <button id="clearText">Clear</button>
          </div>
        </div>

        <div class="tab" id="tab-gutenberg" style="display:none;">
          <div class="muted">Search Project Gutenberg (via Gutendex).</div>
          <div style="height:10px;"></div>

          <div class="row">
            <input id="q" placeholder="Search title/author (e.g., Moby Dick, Austen)" />
            <button id="searchBtn" class="primary">Search</button>
          </div>

          <div style="height:10px;"></div>
          <div class="row">
            <select id="lang">
              <option value="">Any language</option>
              <option value="en" selected>English</option>
              <option value="fr">French</option>
              <option value="de">German</option>
              <option value="es">Spanish</option>
            </select>
            <select id="maxResults">
              <option>10</option>
              <option selected>20</option>
              <option>40</option>
            </select>
          </div>

          <div id="searchStatus" class="status"></div>
          <div id="results"></div>
        </div>

        <div class="tab" id="tab-epub" style="display:none;">
          <div class="muted">When an EPUB is loaded, chapters show here.</div>
          <div style="height:10px;"></div>

          <div class="row" style="align-items:center;">
            <label class="muted" style="display:flex; gap:8px; align-items:center;">
              <input id="autoPlayEpub" type="checkbox" style="width:auto;" />
              Auto-play next chapter
            </label>
          </div>

          <div class="row" style="margin-top:8px;">
            <button id="prevChapter" class="ghost">◀ Prev</button>
            <button id="nextChapter" class="ghost">Next ▶</button>
          </div>

          <div class="toc" id="toc"></div>
          <div id="epubStatus" class="status"></div>
        </div>

        <div class="tab" id="tab-tips" style="display:none;">
          <div class="muted" style="line-height:1.6;">
            <b>If changes don’t show on your phone:</b><br/>
            You’re cached. See the “Uncache” steps I gave you below this code.<br/><br/>
            <b>PDFs:</b><br/>
            Some PDFs are just images (scans). Those won’t extract text without OCR. Text-based PDFs should work.<br/><br/>
            <b>Best voice quality:</b><br/>
            iOS voices depend on what’s installed: Settings → Accessibility → Spoken Content → Voices.
          </div>
        </div>

      </div>
    </section>

    <section class="card">
      <div class="hd">
        <span id="docLabel">Reader</span>
        <span class="muted" id="modeLabel">mode: text</span>
      </div>
      <div class="bd">
        <div class="muted">Tap a sentence to jump. Long-press to scrub.</div>

        <div class="progressWrap">
          <div class="progressBar"><div id="progressFill" class="progressFill"></div></div>
          <div id="progressText" class="muted" style="margin-top:6px;">0%</div>
        </div>

        <div style="height:10px;"></div>
        <div id="reader">Load something, then press Speak.</div>

        <div id="ttsStatus" class="status"></div>
      </div>
    </section>
  </div>

  <!-- Floating player -->
  <div class="playerFab" id="playerFab">
    <button class="fabMain" id="fabToggle" aria-label="Toggle player">
      <span id="fabIcon">▶</span>
      <span id="fabPct" class="fabPct">0%</span>
    </button>

    <div class="fabPanel" id="fabPanel" aria-hidden="true">
      <div class="row" style="gap:8px; margin-bottom:10px;">
        <select id="voiceSelect" aria-label="Voice"></select>
      </div>

      <div class="row" style="gap:8px;">
        <button id="speak" class="primary" style="width:auto;">▶ Speak</button>
        <button id="pause" class="ghost" style="width:auto;">⏸</button>
        <button id="resume" class="ghost" style="width:auto;">⏵</button>
        <button id="stop" class="danger" style="width:auto;">■</button>
      </div>

      <div class="row" style="gap:12px; margin-top:10px; align-items:center;">
        <label class="muted" style="display:flex; gap:8px; align-items:center; flex:1;">
          <input id="highlightToggle" type="checkbox" style="width:auto;" checked />
          Highlight
        </label>
        <label class="muted" style="display:flex; gap:8px; align-items:center; flex:1;">
          <input id="setStartMode" type="checkbox" style="width:auto;" />
          Set Start Here
        </label>
      </div>

      <div style="height:10px;"></div>
      <div class="muted">Rate</div>
      <input id="rate" type="range" min="0.7" max="1.2" value="1.0" step="0.05" />

      <div style="height:10px;"></div>
      <div class="muted">Pitch</div>
      <input id="pitch" type="range" min="0.8" max="1.2" value="1.0" step="0.05" />
    </div>
  </div>
</div>

<!-- Scrub overlay -->
<div id="scrubOverlay">
  <div id="scrubCard">
    <h3 style="margin:0 0 8px 0; font-size:14px;">Jump to a spot</h3>
    <input id="scrubRange" type="range" min="0" max="0" value="0" />
    <div class="row" style="margin-top:10px;">
      <button id="scrubSet" class="primary">Set start here</button>
      <button id="scrubSpeak" class="ghost">Set + Speak</button>
      <button id="scrubCancel">Cancel</button>
    </div>
    <div id="scrubPreview"></div>
  </div>
</div>

<div id="epubHidden"></div>

<script>
  // Tabs
  const chips = [...document.querySelectorAll(".chip")];
  const tabs = {
    load: document.getElementById("tab-load"),
    gutenberg: document.getElementById("tab-gutenberg"),
    epub: document.getElementById("tab-epub"),
    tips: document.getElementById("tab-tips"),
  };
  const leftTitle = document.getElementById("leftTitle");
  function setTab(name){
    chips.forEach(c => c.classList.toggle("active", c.dataset.tab === name));
    Object.entries(tabs).forEach(([k,el]) => el.style.display = (k===name ? "block" : "none"));
    leftTitle.textContent = name.charAt(0).toUpperCase() + name.slice(1);
  }
  chips.forEach(c => c.addEventListener("click", () => setTab(c.dataset.tab)));

  // DOM
  const fileInput = document.getElementById("fileInput");
  const fileStatus = document.getElementById("fileStatus");
  const pasteBox = document.getElementById("pasteBox");
  const usePaste = document.getElementById("usePaste");
  const clearText = document.getElementById("clearText");

  const reader = document.getElementById("reader");
  const docLabel = document.getElementById("docLabel");
  const modeLabel = document.getElementById("modeLabel");

  const voiceSelect = document.getElementById("voiceSelect");
  const rate = document.getElementById("rate");
  const pitch = document.getElementById("pitch");
  const highlightToggle = document.getElementById("highlightToggle");
  const setStartMode = document.getElementById("setStartMode");

  const speakBtn = document.getElementById("speak");
  const pauseBtn = document.getElementById("pause");
  const resumeBtn = document.getElementById("resume");
  const stopBtn = document.getElementById("stop");
  const ttsStatus = document.getElementById("ttsStatus");

  const progressFill = document.getElementById("progressFill");
  const progressText = document.getElementById("progressText");

  const q = document.getElementById("q");
  const searchBtn = document.getElementById("searchBtn");
  const searchStatus = document.getElementById("searchStatus");
  const results = document.getElementById("results");
  const lang = document.getElementById("lang");
  const maxResults = document.getElementById("maxResults");

  const tocEl = document.getElementById("toc");
  const epubStatus = document.getElementById("epubStatus");
  const autoPlayEpub = document.getElementById("autoPlayEpub");
  const prevChapterBtn = document.getElementById("prevChapter");
  const nextChapterBtn = document.getElementById("nextChapter");
  const epubHidden = document.getElementById("epubHidden");

  const scrubOverlay = document.getElementById("scrubOverlay");
  const scrubRange = document.getElementById("scrubRange");
  const scrubPreview = document.getElementById("scrubPreview");
  const scrubSet = document.getElementById("scrubSet");
  const scrubSpeak = document.getElementById("scrubSpeak");
  const scrubCancel = document.getElementById("scrubCancel");

  const fabToggle = document.getElementById("fabToggle");
  const fabPanel = document.getElementById("fabPanel");
  const fabIcon = document.getElementById("fabIcon");
  const fabPct = document.getElementById("fabPct");

  // PDF.js worker
  if (window.pdfjsLib) {
    pdfjsLib.GlobalWorkerOptions.workerSrc =
      "https://unpkg.com/pdfjs-dist@4.10.38/build/pdf.worker.min.js";
  }

  // Storage
  const STORAGE = {
    lastMode: "pr_lastMode",
    lastText: "pr_lastText",
    lastLabel: "pr_lastLabel",
    lastRate: "pr_rate",
    lastPitch: "pr_pitch",
    lastVoice: "pr_voice",
    highlight: "pr_highlight",
    setStartMode: "pr_setStartMode",
    autoPlay: "pr_autoplay_epub",
    lastEpubHref: "pr_lastEpubHref",
    resumeIdx: "pr_resumeSentenceIdx"
  };

  // State
  const state = {
    mode: "text",
    label: "Loaded",
    textRaw: "",
    sentences: [],
    sentenceEls: [],
    currentSentenceIndex: 0,
    voices: [],
    speaking: false,

    epub: null,
    epubRendition: null,
    epubTocFlat: [],
    activeTocIndex: -1
  };

  // Helpers
  function setStatus(el, msg, kind="ok"){
    el.textContent = msg || "";
    el.className = "status " + (kind==="warn" ? "warn" : (kind==="danger" ? "dangerText" : ""));
  }
  function setDocTitle(label, mode){
    docLabel.textContent = label || "Reader";
    modeLabel.textContent = "mode: " + (mode || "text");
  }
  function escapeHtml(str){
    return String(str).replace(/[&<>"']/g, s => ({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
    }[s]));
  }
  function escapeAttr(str){ return escapeHtml(str).replace(/"/g, "&quot;"); }

  function stripHtmlIfNeeded(text, filenameLower=""){
    if (!text) return "";
    const looksHtml =
      filenameLower.endsWith(".html") ||
      filenameLower.endsWith(".htm") ||
      /<\/(p|div|h1|h2|h3|br|body|html)>/i.test(text);
    if (!looksHtml) return text;
    const tmp = document.createElement("div");
    tmp.innerHTML = text;
    tmp.querySelectorAll("script,style").forEach(el => el.remove());
    const out = (tmp.textContent || tmp.innerText || "").trim();
    return out.replace(/\n{3,}/g, "\n\n");
  }

  function htmlToText(html){
    const tmp = document.createElement("div");
    tmp.innerHTML = html || "";
    tmp.querySelectorAll("script,style").forEach(el => el.remove());
    const text = (tmp.textContent || tmp.innerText || "").trim();
    return text.replace(/\n{3,}/g, "\n\n");
  }

  function splitIntoSentences(text){
    const t = (text || "").replace(/\r\n/g, "\n").trim();
    if (!t) return [];
    const parts = t.split(/(?<=[.!?])\s+(?=[A-Z0-9“"'\(\[])/g);
    return parts.map(s => s.trim()).filter(Boolean);
  }

  function renderReaderWithSentences(sentences){
    reader.innerHTML = "";
    state.sentenceEls = [];
    if (!sentences.length) { reader.textContent = "No text loaded."; return; }
    const frag = document.createDocumentFragment();
    sentences.forEach((s, idx) => {
      const span = document.createElement("span");
      span.className = "sent";
      span.dataset.idx = String(idx);
      span.textContent = s + " ";
      state.sentenceEls[idx] = span;
      frag.appendChild(span);
    });
    reader.appendChild(frag);
  }

  function clearActiveHighlight(){
    for (const el of state.sentenceEls) if (el) el.classList.remove("active");
  }
  function setActiveHighlight(i){
    if (!highlightToggle.checked) return;
    clearActiveHighlight();
    const el = state.sentenceEls[i];
    if (!el) return;
    el.classList.add("active");
    try { el.scrollIntoView({ block:"center", behavior:"smooth" }); } catch(e){}
  }

  function updateProgress(){
    const total = state.sentences.length || 0;
    const idx = Math.max(0, Math.min(state.currentSentenceIndex, Math.max(0, total-1)));
    const pct = total ? Math.round((idx / total) * 100) : 0;
    progressFill.style.width = pct + "%";
    progressText.textContent = total ? `${pct}% (sentence ${idx+1} of ${total})` : "0%";
    if (fabPct) fabPct.textContent = total ? `${pct}%` : "0%";
  }

  // TTS
  function stopSpeaking(){
    try { speechSynthesis.cancel(); } catch(e) {}
    state.speaking = false;
    setStatus(ttsStatus, "");
    clearActiveHighlight();
    if (fabIcon) fabIcon.textContent = "▶";
  }
  function getSelectedVoice(){
    const name = voiceSelect.value;
    return state.voices.find(v => v.name === name) || null;
  }
  function speakFrom(index){
    if (!state.textRaw.trim()) { setStatus(ttsStatus, "No text loaded.", "warn"); return; }
    stopSpeaking();
    state.speaking = true;
    state.currentSentenceIndex = Math.max(0, Math.min(index, state.sentences.length - 1));
    localStorage.setItem(STORAGE.resumeIdx, String(state.currentSentenceIndex));
    updateProgress();
    if (fabIcon) fabIcon.textContent = "⏸";
    speakNextSentence();
  }
  function speakNextSentence(){
    if (!state.speaking) return;

    if (state.currentSentenceIndex >= state.sentences.length){
      state.speaking = false;
      setStatus(ttsStatus, "Finished.", "ok");
      clearActiveHighlight();
      if (fabIcon) fabIcon.textContent = "▶";

      if (state.mode === "epub" && autoPlayEpub.checked){
        setTimeout(() => goToAdjacentChapter(+1, true), 350);
      }
      return;
    }

    const s = state.sentences[state.currentSentenceIndex];
    const voice = getSelectedVoice();

    setActiveHighlight(state.currentSentenceIndex);
    updateProgress();

    const u = new SpeechSynthesisUtterance(s);
    if (voice) u.voice = voice;
    u.rate = parseFloat(rate.value);
    u.pitch = parseFloat(pitch.value);

    u.onstart = () => setStatus(ttsStatus, `Speaking ${state.currentSentenceIndex+1}/${state.sentences.length} • ${state.label}`, "ok");
    u.onerror = () => {
      state.speaking = false;
      setStatus(ttsStatus, "Speech error. Try a different voice.", "warn");
      clearActiveHighlight();
      if (fabIcon) fabIcon.textContent = "▶";
    };
    u.onend = () => {
      state.currentSentenceIndex += 1;
      localStorage.setItem(STORAGE.resumeIdx, String(state.currentSentenceIndex));
      speakNextSentence();
    };

    speechSynthesis.speak(u);
  }

  function populateVoices(){
    const vs = speechSynthesis.getVoices();
    if (!vs || !vs.length) return;
    state.voices = vs;
    voiceSelect.innerHTML = "";

    const sorted = [...vs].sort((a,b) => {
      const aUS = (a.lang || "").toLowerCase().includes("en-us");
      const bUS = (b.lang || "").toLowerCase().includes("en-us");
      if (aUS !== bUS) return bUS - aUS;
      return (a.name || "").localeCompare(b.name || "");
    });

    for (const v of sorted){
      const opt = document.createElement("option");
      opt.value = v.name;
      opt.textContent = `${v.name} — ${v.lang}${v.default ? " (default)" : ""}`;
      voiceSelect.appendChild(opt);
    }

    const saved = localStorage.getItem(STORAGE.lastVoice);
    const preferred = saved && sorted.some(v => v.name === saved)
      ? saved
      : (sorted.find(v => (v.lang || "").toLowerCase().includes("en-us"))?.name || sorted[0]?.name);

    if (preferred) voiceSelect.value = preferred;
  }

  function loadText(text, label, mode="text"){
    stopSpeaking();
    state.mode = mode;
    state.label = label || "Loaded";
    state.textRaw = text || "";

    state.sentences = splitIntoSentences(state.textRaw);

    let idx = parseInt(localStorage.getItem(STORAGE.resumeIdx) || "0", 10);
    if (Number.isNaN(idx) || idx < 0 || idx >= state.sentences.length) idx = 0;
    state.currentSentenceIndex = idx;

    renderReaderWithSentences(state.sentences);
    setDocTitle(state.label, state.mode);

    localStorage.setItem(STORAGE.lastMode, state.mode);
    localStorage.setItem(STORAGE.lastText, state.textRaw);
    localStorage.setItem(STORAGE.lastLabel, state.label);

    if (!state.textRaw.trim()){
      setStatus(fileStatus, "No text loaded.", "warn");
    } else {
      setStatus(fileStatus, `${state.label} (${state.textRaw.length.toLocaleString()} chars)`, "ok");
    }

    setActiveHighlight(state.currentSentenceIndex);
    updateProgress();
  }

  // DOCX extraction
  async function docxToText(arrayBuffer){
    const result = await mammoth.extractRawText({ arrayBuffer });
    return (result && result.value ? result.value : "").replace(/\n{3,}/g, "\n\n").trim();
  }

  // PDF extraction
  async function pdfToText(arrayBuffer){
    if (!window.pdfjsLib) throw new Error("PDF engine not loaded");
    const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer });
    const pdf = await loadingTask.promise;
    let out = [];
    for (let p = 1; p <= pdf.numPages; p++){
      const page = await pdf.getPage(p);
      const tc = await page.getTextContent();
      const pageText = tc.items.map(it => it.str).join(" ");
      out.push(pageText);
    }
    return out.join("\n\n").replace(/\s{2,}/g, " ").trim();
  }

  // EPUB
  function flattenToc(toc, out=[]){
    for (const item of (toc || [])){
      out.push({ label: item.label || "(untitled)", href: item.href });
      if (item.subitems && item.subitems.length) flattenToc(item.subitems, out);
    }
    return out;
  }
  function updateTocActive(){
    [...tocEl.querySelectorAll("button")].forEach(b => {
      const idx = parseInt(b.dataset.idx, 10);
      b.classList.toggle("active", idx === state.activeTocIndex);
    });
  }
  async function loadEpubChapterByIndex(idx, autoSpeak=false){
    if (!state.epub || !state.epubTocFlat.length) return;
    if (idx < 0 || idx >= state.epubTocFlat.length) return;

    stopSpeaking();
    state.activeTocIndex = idx;
    updateTocActive();

    const item = state.epubTocFlat[idx];
    const label = item.label || `Chapter ${idx+1}`;
    setStatus(epubStatus, `Loading: ${label}…`, "ok");

    try{
      const section = await state.epub.section(item.href);
      const contents = await section.load(state.epub.load.bind(state.epub));
      const html = contents?.document ? contents.document.documentElement.outerHTML : "";
      const text = htmlToText(html);

      localStorage.setItem(STORAGE.lastEpubHref, item.href);
      localStorage.setItem(STORAGE.resumeIdx, "0");

      loadText(text, `EPUB: ${label}`, "epub");
      setTab("epub");
      setStatus(epubStatus, `Loaded: ${label}`, "ok");

      if (autoSpeak) speakFrom(0);
    } catch(e){
      console.error(e);
      setStatus(epubStatus, "Could not load that chapter.", "warn");
    }
  }
  function goToAdjacentChapter(delta, autoSpeak=false){
    if (state.mode !== "epub" || !state.epubTocFlat.length) return;
    const next = state.activeTocIndex + delta;
    if (next < 0 || next >= state.epubTocFlat.length){
      setStatus(epubStatus, "No more chapters.", "warn");
      return;
    }
    loadEpubChapterByIndex(next, autoSpeak);
  }
  async function loadEpubFromArrayBuffer(buf, label){
    stopSpeaking();
    setStatus(epubStatus, "Loading EPUB…", "ok");
    tocEl.innerHTML = "";
    state.epubTocFlat = [];
    state.activeTocIndex = -1;

    try{
      state.epub = ePub(buf);
      epubHidden.innerHTML = "";
      state.epubRendition = state.epub.renderTo(epubHidden, { width:900, height:700 });

      const nav = await state.epub.loaded.navigation;
      const toc = nav?.toc ? nav.toc : [];
      state.epubTocFlat = flattenToc(toc, []);

      if (!state.epubTocFlat.length){
        setStatus(epubStatus, "No TOC found. Trying spine…", "warn");
        const spine = await state.epub.loaded.spine;
        const first = spine?.items?.[0];
        if (!first) throw new Error("No spine items.");
        state.epubTocFlat = [{ label:"Start", href:first.href }];
      }

      tocEl.innerHTML = "";
      state.epubTocFlat.forEach((it, idx) => {
        const b = document.createElement("button");
        b.textContent = it.label || "(untitled)";
        b.dataset.idx = String(idx);
        b.addEventListener("click", () => loadEpubChapterByIndex(idx, false));
        tocEl.appendChild(b);
      });

      setStatus(fileStatus, label, "ok");
      setStatus(epubStatus, "EPUB ready.", "ok");
      setTab("epub");

      const savedHref = localStorage.getItem(STORAGE.lastEpubHref);
      const startIdx = savedHref ? state.epubTocFlat.findIndex(x => x.href === savedHref) : 0;
      await loadEpubChapterByIndex(startIdx >= 0 ? startIdx : 0, false);
    } catch(e){
      console.error(e);
      setStatus(epubStatus, "Failed to load EPUB.", "warn");
    }
  }

  // Gutenberg
  async function gutendexSearch(query, language, limit){
    const params = new URLSearchParams();
    params.set("search", query);
    if (language) params.set("languages", language);
    params.set("page", "1");
    const url = `https://gutendex.com/books?${params.toString()}`;
    const res = await fetch(url);
    if (!res.ok) throw new Error("Search failed");
    const data = await res.json();
    return (data.results || []).slice(0, limit);
  }
  function pickBestTextUrl(formats){
    const keys = Object.keys(formats || {});
    const prefer = ["text/plain; charset=utf-8","text/plain; charset=us-ascii","text/plain"];
    for (const p of prefer){
      const hit = keys.find(k => k.toLowerCase().startsWith(p));
      if (hit) return formats[hit];
    }
    return null;
  }
  function pickEpubUrl(formats){
    const keys = Object.keys(formats || {});
    const hit = keys.find(k => k.toLowerCase().includes("application/epub+zip"));
    return hit ? formats[hit] : null;
  }
  function trimGutenbergBoilerplate(text){
    const t = text || "";
    const startMarkers = [
      "*** START OF THE PROJECT GUTENBERG EBOOK",
      "***START OF THE PROJECT GUTENBERG EBOOK",
      "*** START OF THIS PROJECT GUTENBERG EBOOK",
      "***START OF THIS PROJECT GUTENBERG EBOOK"
    ];
    const endMarkers = [
      "*** END OF THE PROJECT GUTENBERG EBOOK",
      "***END OF THE PROJECT GUTENBERG EBOOK",
      "*** END OF THIS PROJECT GUTENBERG EBOOK",
      "***END OF THIS PROJECT GUTENBERG EBOOK"
    ];
    let start = 0;
    for (const m of startMarkers){
      const i = t.indexOf(m);
      if (i !== -1){ start = i; break; }
    }
    if (start > 0){
      const nl = t.indexOf("\n", start);
      if (nl !== -1) start = nl + 1;
    }
    let end = t.length;
    for (const m of endMarkers){
      const i = t.indexOf(m);
      if (i !== -1){ end = i; break; }
    }
    const sliced = t.slice(start, end).trim();
    return sliced.length > 200 ? sliced : t.trim();
  }
  async function loadGutenbergText(url, title){
    try{
      setStatus(searchStatus, "Loading text…", "ok");
      const res = await fetch(url);
      if (!res.ok) throw new Error("Fetch failed");
      const text = await res.text();
      localStorage.setItem(STORAGE.resumeIdx, "0");
      loadText(trimGutenbergBoilerplate(text), `Gutenberg: ${title}`, "text");
      setStatus(searchStatus, "Loaded.", "ok");
    } catch {
      setStatus(searchStatus, "Direct load blocked. Download and upload instead.", "warn");
    }
  }
  async function loadGutenbergEpub(url, title){
    try{
      setStatus(searchStatus, "Fetching EPUB…", "ok");
      const res = await fetch(url);
      if (!res.ok) throw new Error("EPUB fetch failed");
      const buf = await res.arrayBuffer();
      await loadEpubFromArrayBuffer(buf, `Gutenberg EPUB: ${title}`);
      setStatus(searchStatus, "EPUB loaded.", "ok");
    } catch {
      setStatus(searchStatus, "Direct EPUB read blocked (CORS). Download EPUB and upload.", "warn");
    }
  }

  // Scrubber
  let pressTimer = null;
  function openScrubber(atIdx){
    if (!state.sentences.length) return;
    scrubRange.max = String(state.sentences.length - 1);
    scrubRange.value = String(atIdx);
    updateScrubPreview(atIdx);
    scrubOverlay.style.display = "flex";
  }
  function closeScrubber(){ scrubOverlay.style.display = "none"; }
  function updateScrubPreview(idx){
    const s = state.sentences[idx] || "";
    const preview = s.length > 420 ? s.slice(0,420) + "…" : s;
    scrubPreview.textContent = `Sentence ${idx+1} of ${state.sentences.length}\n\n${preview}`;
  }
  scrubRange.addEventListener("input", () => updateScrubPreview(parseInt(scrubRange.value,10)));
  scrubSet.addEventListener("click", () => {
    const idx = parseInt(scrubRange.value,10);
    state.currentSentenceIndex = idx;
    localStorage.setItem(STORAGE.resumeIdx, String(idx));
    setActiveHighlight(idx);
    updateProgress();
    setStatus(ttsStatus, `Start set: sentence ${idx+1}.`, "ok");
    closeScrubber();
  });
  scrubSpeak.addEventListener("click", () => {
    const idx = parseInt(scrubRange.value,10);
    closeScrubber();
    speakFrom(idx);
  });
  scrubCancel.addEventListener("click", closeScrubber);
  scrubOverlay.addEventListener("click", (e) => { if (e.target === scrubOverlay) closeScrubber(); });

  // Reader interactions
  reader.addEventListener("click", (e) => {
    const sent = e.target.closest(".sent");
    if (!sent) return;
    const idx = parseInt(sent.dataset.idx, 10);
    if (Number.isNaN(idx)) return;

    state.currentSentenceIndex = idx;
    localStorage.setItem(STORAGE.resumeIdx, String(idx));
    setActiveHighlight(idx);
    updateProgress();

    if (!setStartMode.checked) speakFrom(idx);
    else setStatus(ttsStatus, "Start point set. Press Speak.", "ok");
  });

  reader.addEventListener("pointerdown", () => {
    if (!state.sentences.length) return;
    pressTimer = setTimeout(() => openScrubber(state.currentSentenceIndex || 0), 520);
  });
  reader.addEventListener("pointerup", () => { if (pressTimer) clearTimeout(pressTimer); });
  reader.addEventListener("pointermove", () => { if (pressTimer) clearTimeout(pressTimer); });
  reader.addEventListener("pointercancel", () => { if (pressTimer) clearTimeout(pressTimer); });

  // Floating player toggle + hide-on-scroll
  let panelOpen = false;
  fabToggle.addEventListener("click", () => {
    panelOpen = !panelOpen;
    fabPanel.classList.toggle("open", panelOpen);
    fabPanel.setAttribute("aria-hidden", panelOpen ? "false" : "true");
  });
  let scrollTimer = null;
  reader.addEventListener("scroll", () => {
    document.body.classList.add("hideFab");
    if (scrollTimer) clearTimeout(scrollTimer);
    scrollTimer = setTimeout(() => document.body.classList.remove("hideFab"), 420);
  });

  // File loading
  fileInput.addEventListener("change", async (e) => {
    const f = e.target.files && e.target.files[0];
    if (!f) return;

    const name = (f.name || "file").toLowerCase();
    setStatus(fileStatus, `Loading: ${f.name}…`, "ok");

    try{
      // EPUB
      if (name.endsWith(".epub") || f.type === "application/epub+zip"){
        localStorage.setItem(STORAGE.resumeIdx, "0");
        await loadEpubFromArrayBuffer(await f.arrayBuffer(), `Loaded EPUB: ${f.name}`);
        return;
      }

      // DOCX
      if (name.endsWith(".docx") || f.type === "application/vnd.openxmlformats-officedocument.wordprocessingml.document"){
        const text = await docxToText(await f.arrayBuffer());
        localStorage.setItem(STORAGE.resumeIdx, "0");
        loadText(text, `Loaded DOCX: ${f.name}`, "text");
        return;
      }

      // PDF
      if (name.endsWith(".pdf") || f.type === "application/pdf"){
        const text = await pdfToText(await f.arrayBuffer());
        if (!text || text.length < 10) {
          setStatus(fileStatus, "This PDF looks like a scan (image-only). Text extraction won’t work without OCR.", "warn");
          loadText("", "PDF (no extractable text)", "text");
        } else {
          localStorage.setItem(STORAGE.resumeIdx, "0");
          loadText(text, `Loaded PDF: ${f.name}`, "text");
        }
        return;
      }

      // Text / HTML
      const raw = await f.text();
      const cleaned = stripHtmlIfNeeded(raw, name);
      localStorage.setItem(STORAGE.resumeIdx, "0");
      loadText(cleaned, `Loaded file: ${f.name}`, "text");
    } catch(err){
      console.error(err);
      setStatus(fileStatus,
        "Could not read that file. If it’s a PDF: it may be scanned (image-only) or you’re still on a cached build.",
        "warn"
      );
    } finally {
      fileInput.value = "";
    }
  });

  usePaste.addEventListener("click", () => {
    localStorage.setItem(STORAGE.resumeIdx, "0");
    loadText(pasteBox.value || "", "Loaded pasted text", "text");
  });
  clearText.addEventListener("click", () => {
    pasteBox.value = "";
    localStorage.setItem(STORAGE.resumeIdx, "0");
    loadText("", "Cleared", "text");
  });

  // Controls
  speakBtn.addEventListener("click", () => speakFrom(state.currentSentenceIndex || 0));
  pauseBtn.addEventListener("click", () => { try { speechSynthesis.pause(); } catch(e){} if (fabIcon) fabIcon.textContent = "▶"; });
  resumeBtn.addEventListener("click", () => { try { speechSynthesis.resume(); } catch(e){} if (fabIcon) fabIcon.textContent = "⏸"; });
  stopBtn.addEventListener("click", stopSpeaking);

  voiceSelect.addEventListener("change", () => localStorage.setItem(STORAGE.lastVoice, voiceSelect.value));
  rate.addEventListener("change", () => localStorage.setItem(STORAGE.lastRate, String(rate.value)));
  pitch.addEventListener("change", () => localStorage.setItem(STORAGE.lastPitch, String(pitch.value)));
  highlightToggle.addEventListener("change", () => {
    localStorage.setItem(STORAGE.highlight, highlightToggle.checked ? "1" : "0");
    if (!highlightToggle.checked) clearActiveHighlight();
    else setActiveHighlight(state.currentSentenceIndex);
  });
  setStartMode.addEventListener("change", () => localStorage.setItem(STORAGE.setStartMode, setStartMode.checked ? "1" : "0"));
  autoPlayEpub.addEventListener("change", () => localStorage.setItem(STORAGE.autoPlay, autoPlayEpub.checked ? "1" : "0"));

  prevChapterBtn.addEventListener("click", () => goToAdjacentChapter(-1, false));
  nextChapterBtn.addEventListener("click", () => goToAdjacentChapter(+1, false));

  // Gutenberg search
  async function doSearch(){
    const query = (q.value || "").trim();
    if (!query){ setStatus(searchStatus, "Type a search query.", "warn"); return; }
    searchBtn.disabled = true;
    results.innerHTML = "";
    setStatus(searchStatus, "Searching…", "ok");

    try{
      const items = await gutendexSearch(query, lang.value, parseInt(maxResults.value,10));
      results.innerHTML = "";
      if (!items.length){
        results.innerHTML = `<div class="muted">No results.</div>`;
      } else {
        items.forEach(b => {
          const title = b.title || "Untitled";
          const authors = (b.authors || []).map(a => a.name).join(", ") || "Unknown author";
          const langs = (b.languages || []).join(", ") || "n/a";
          const downloads = (b.download_count ?? 0).toLocaleString();
          const textUrl = pickBestTextUrl(b.formats);
          const epubUrl = pickEpubUrl(b.formats);

          const div = document.createElement("div");
          div.className = "result";
          div.innerHTML = `
            <div class="title">${escapeHtml(title)}</div>
            <div class="meta">${escapeHtml(authors)} • lang: ${escapeHtml(langs)} • downloads: ${downloads}</div>
            <div class="pills">
              ${textUrl ? `<span class="pill" data-action="readText" data-url="${escapeAttr(textUrl)}">Read (text)</span>` : ""}
              ${epubUrl ? `<span class="pill" data-action="readEpub" data-url="${escapeAttr(epubUrl)}">Read (EPUB)</span>` : ""}
              ${textUrl ? `<a class="pill" href="${textUrl}" target="_blank" rel="noopener">Download text</a>` : ""}
              ${epubUrl ? `<a class="pill" href="${epubUrl}" target="_blank" rel="noopener">Download EPUB</a>` : ""}
            </div>
          `;
          div.addEventListener("click", async (e) => {
            const pill = e.target.closest(".pill");
            if (!pill) return;
            const action = pill.getAttribute("data-action");
            const url = pill.getAttribute("data-url");
            if (action === "readText") await loadGutenbergText(url, title);
            if (action === "readEpub") await loadGutenbergEpub(url, title);
          });
          results.appendChild(div);
        });
      }
      setStatus(searchStatus, `Found ${items.length} result(s).`, "ok");
    } catch(e){
      console.error(e);
      setStatus(searchStatus, "Search failed.", "warn");
    } finally {
      searchBtn.disabled = false;
    }
  }
  searchBtn.addEventListener("click", () => { setTab("gutenberg"); doSearch(); });
  q.addEventListener("keydown", (e) => { if (e.key === "Enter") { setTab("gutenberg"); doSearch(); } });

  // Restore
  function restore(){
    const savedRate = localStorage.getItem(STORAGE.lastRate);
    const savedPitch = localStorage.getItem(STORAGE.lastPitch);
    const savedVoice = localStorage.getItem(STORAGE.lastVoice);
    const savedHighlight = localStorage.getItem(STORAGE.highlight);
    const savedSetStart = localStorage.getItem(STORAGE.setStartMode);
    const savedAuto = localStorage.getItem(STORAGE.autoPlay);

    if (savedRate) rate.value = savedRate;
    if (savedPitch) pitch.value = savedPitch;
    if (savedHighlight) highlightToggle.checked = savedHighlight === "1";
    if (savedSetStart) setStartMode.checked = savedSetStart === "1";
    autoPlayEpub.checked = savedAuto === "1";

    populateVoices();
    if (savedVoice) voiceSelect.value = savedVoice;

    const lastText = localStorage.getItem(STORAGE.lastText) || "";
    const lastLabel = localStorage.getItem(STORAGE.lastLabel) || "Restored";
    const lastMode = localStorage.getItem(STORAGE.lastMode) || "text";

    if (lastText) loadText(lastText, lastLabel, lastMode);
    else { setDocTitle("Reader", "text"); updateProgress(); }
  }

  if (typeof speechSynthesis !== "undefined"){
    populateVoices();
    speechSynthesis.onvoiceschanged = populateVoices;
  } else {
    setStatus(ttsStatus, "SpeechSynthesis not supported in this browser.", "warn");
  }
  restore();

  // PWA install button (Android/desktop only)
  let deferredPrompt = null;
  const installBtn = document.getElementById("installBtn");
  window.addEventListener("beforeinstallprompt", (e) => {
    e.preventDefault();
    deferredPrompt = e;
    installBtn.style.display = "inline-block";
  });
  installBtn.addEventListener("click", async () => {
    if (!deferredPrompt) return;
    deferredPrompt.prompt();
    await deferredPrompt.userChoice;
    deferredPrompt = null;
    installBtn.style.display = "none";
  });

  // Service worker
  if ("serviceWorker" in navigator) {
    window.addEventListener("load", () => {
      navigator.serviceWorker.register("./sw.js").catch(() => {});
    });
  }
</script>
</body>
</html>
